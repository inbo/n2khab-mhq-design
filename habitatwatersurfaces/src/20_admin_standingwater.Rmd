# Assessments of sampling units

## Admin data for watersurfaces

An overview of the assessed watersurfaces is provided 

+ in the file OverzichtMeetnet&Steekproef_HT31XX_11_12_2020.xlsx for types 31xx
+ in the file Steekproefkader_2190_versie20170606.shp

Both files can be found in [this google drive folder](https://drive.google.com/drive/folders/19NsppwrC47ZAjv8Ndoh6aChkdud801T2).


### Habitat types 31xx

The admin data provide information on:

+ type observed
+ area class observed
+ the year in which an abiotic measurement was performed
+ the year in which an biotic measurement was performed
+ the code of the actual watersurface that was assessed (the polygons of the 2014 sample can contain several watersurfaces)
+ the code that is used in inboveg

```{r}
admin_orig <- read_excel("../data/OverzichtMeetnet&Steekproef_HT31XX_11_12_2020.xlsx")

admin_assessments_watersurfaces <- admin_orig %>%
  mutate(sac = ifelse(!is.na(SBZH), SBZH, SBZ)) %>%
  select(pol_id = ID_Plas, sac, type_target = doelhabt, code_inboveg = CODE, code_watersurfaces =  Watervlakk, monitoring_type = meetnet, assessment = geprospecteerd, year_abiotic = Abiotiek_j, year_biotic = Biotiek_ja, is_type_target = Doelhabitat, type_observed = HabtypeVel, note = Opmerking2, area_class_observed = starts_with("Werkelijke") ) %>%
  mutate(type_observed = ifelse(type_observed == "?", "unknown", type_observed),
         assessment = ifelse(pol_id == "extra", "ja", assessment),
         pol_id = ifelse(pol_id == "extra", str_c("extra_", code_inboveg), pol_id),
         code_watersurfaces = ifelse(code_inboveg == "WV_LEI_001", "WVLOSK0532", code_watersurfaces), #correction after manual check: TO BE CORRECTED in admin data source
         area_class_observed = factor(area_class_observed, levels = c("Opp <= 1 ha", "1 ha < Opp <= 5 ha", "5 ha < Opp < 50 ha", "> 50 ha"))) %>%
  mutate(assessment = assessment == "ja" & !is.na(assessment)) %>%
  filter(assessment) %>%
  group_by(pol_id, sac, code_inboveg, code_watersurfaces, monitoring_type, assessment, year_abiotic, year_biotic, type_observed, area_class_observed, note) %>%
  summarise(n_target_types = n(),
         any_type_target = "ja" %in% is_type_target) %>%
  ungroup()

admin_assessments_watersurfaces_types <- admin_assessments_watersurfaces %>%
  separate_rows(type_observed, sep = ";")

```




### Habitattype 2190

```{r}

watersurfaces <- read_watersurfaces() %>%
  select(code_watersurfaces = polygon_id)

admin_2190_orig <- read_sf("../data/voortgang_2190/Steekproefkader_2190_versie20170606.shp") %>%
  st_drop_geometry() 

admin_assessments_2190 <- admin_2190_orig %>%
  mutate(sac = ifelse(!is.na(SBZH), SBZH, SBZ),
         assessment = !is.na(CODE),
         type_observed = ifelse(Abiotiek_j != 0, "2190", NA),
         any_type_target = ifelse(Abiotiek_j != 0, TRUE, NA),
         note = ifelse(str_sub(CODE, 1, 2) == "WV", str_sub(CODE, 11), CODE),
         code_inboveg = ifelse(str_sub(CODE, 1, 2) == "WV", str_sub(CODE, 1, 10), NA),
         area_class_observed = ifelse(OppKlasse == "1 ha < Opp <= 5 ha", OppKlasse, "Opp <= 1 ha")) %>%
  select(pol_id = ID_plas, sac, type_observed, code_inboveg, assessment, year_abiotic = Abiotiek_j, year_biotic = Biotiek_ja,  type_observed, note, area_class_observed, any_type_target) %>%
  mutate(area_class_observed = factor(area_class_observed, levels = c("Opp <= 1 ha", "1 ha < Opp <= 5 ha", "5 ha < Opp < 50 ha", "Opp >= 50 ha"))) %>%
  filter(assessment) %>%
  mutate(pol_id = as.character(pol_id),
         year_abiotic = ifelse(year_abiotic == 0, NA, year_abiotic),
         year_biotic = ifelse(year_biotic == 0, NA, year_biotic),
         n_target_types = 1,
         monitoring_type = "habitat")

admin_assessments_watersurfaces_types <- admin_assessments_watersurfaces_types %>%
  bind_rows(admin_assessments_2190)

check <- admin_assessments_watersurfaces_types %>%
  group_by(pol_id, type_observed) %>%
  mutate(n_recs = n()) %>%
  ungroup() %>%
  filter(n_recs > 1)

```


## Join sampling units data and admin data

```{r}
# one record per polygon
mhq_watersurfaces_pol <- mhq_watersurfaces_types %>%
  group_by(pol_id, sac, grts_ranking, grts_ranking_draw, set) %>%
  arrange(type_target, area_class) %>%
  summarise(type_target_all = str_c(type_target, collapse = ";"),
            area_class_all = str_c(area_class, collapse = ";")) %>%
  ungroup()

check <- unique(mhq_watersurfaces_pol$pol_id) == nrow(mhq_watersurfaces_pol)

assessments_mhq_watersurfaces <- mhq_watersurfaces_pol %>%
  full_join(admin_assessments_watersurfaces_types, by = c("pol_id", "sac")) %>%
  mutate(measurement_biotic = (!is.na(year_biotic)) & (year_biotic != 0),
         measurement_abiotic = (!is.na(year_abiotic)) & (year_abiotic != 0),
         is_type_target = str_detect(type_target_all, type_observed),
         is_type_target = ifelse(is.na(is_type_target) & assessment, FALSE, is_type_target),
         set = ifelse(is.na(set), "extra", set)) #%>%
  # filter(assessment & !is.na(assessment))

# check unique pol_id/type_observed
check <- assessments_mhq_watersurfaces %>%
  group_by(pol_id, type_observed) %>%
  mutate(n_recs = n()) %>%
  ungroup() %>%
  filter(n_recs > 1)

check_any_type_target <- assessments_mhq_watersurfaces %>%
  filter(!is.na(type_observed)) %>%
  mutate(is_type_target_check = str_detect(type_target_all, type_observed)) %>%
  group_by(pol_id, grts_ranking, type_target_all, any_type_target) %>%
  summarise(any_type_target_check = any(is_type_target_check),
            type_observed_all = str_c(type_observed, collapse = ";"),
            set = str_c(unique(set), collapse = ";")) %>%
  ungroup() %>%
  filter(any_type_target_check != any_type_target)
  
```

### Extra watersurfaces

The admin data contains some extra watersurfaces which are not included in the initially selected sampling units. 
These extra watersurfaces were measured for two reasons:

+ the watersurface contains a type for which it was decided to select and measure all exisiting sampling units
+ the watersurface replaces a nearby sampling unit which did not contain the target type 

We determine the grts-ranking of the extra watersurfaces using point_on_surface.

```{r}
mhq_watersurfaces_refpoints_extra <- assessments_mhq_watersurfaces %>%
  filter(set == "extra") %>%
  distinct(pol_id, code_watersurfaces) %>%
  left_join(watersurfaces, by = "code_watersurfaces") %>%
  st_as_sf() %>%
  st_point_on_surface() %>%
  mutate(grts_ranking_extra = grts_master[as(., "Spatial")]) 

assessments_mhq_watersurfaces <- assessments_mhq_watersurfaces %>%
  left_join(st_drop_geometry(mhq_watersurfaces_refpoints_extra), by = c("code_watersurfaces", "pol_id")) %>%
  mutate(grts_ranking = ifelse(is.na(grts_ranking) & set == "extra", grts_ranking_extra, grts_ranking)) %>%
  select(-grts_ranking_extra)
```

### Handle replacements

```{r}

mhq_watersurfaces_refpoints_orig <- read_sf(dsn = "../output/mhq_watersurfaces_original.gpkg", layer = "refpoints_original")

coord_extra <- mhq_watersurfaces_refpoints_extra %>%
  st_drop_geometry() %>%
  mutate(x = st_coordinates(mhq_watersurfaces_refpoints_extra)[,1],
         y = st_coordinates(mhq_watersurfaces_refpoints_extra)[,2]) %>%
  select(-grts_ranking_extra, -code_watersurfaces) 

coord_sample_replaced <- mhq_watersurfaces_refpoints_orig %>%
  st_drop_geometry() %>%
  mutate(x_replaced = st_coordinates(mhq_watersurfaces_refpoints_orig)[,1],
         y_replaced = st_coordinates(mhq_watersurfaces_refpoints_orig)[,2]) %>%
  select(-grts_ranking) %>%
  rename(pol_id_replaced = pol_id)

coord_sample <- mhq_watersurfaces_refpoints_orig %>%
  st_drop_geometry() %>%
  mutate(x = st_coordinates(mhq_watersurfaces_refpoints_orig)[,1],
         y= st_coordinates(mhq_watersurfaces_refpoints_orig)[,2]) %>%
  select(-grts_ranking)

replacement_31xx <- assessments_mhq_watersurfaces %>%
  filter(str_detect(note, c("verschuiving van|verschoven van"))) %>%
  mutate(pol_id_replaced = word(note, -1)) %>%
  filter(set == "extra") %>%
  select(-grts_ranking_draw, -type_target_all, -area_class_all) %>%
  left_join(select(assessments_mhq_watersurfaces, pol_id_replaced = pol_id, grts_ranking_draw, type_target_all, area_class_all, code_watersurfaces_replaced = code_watersurfaces), by = "pol_id_replaced") %>%
  distinct() %>%
  mutate(replaced = TRUE,
         is_type_target = str_detect(type_target_all, type_observed)) %>%
  left_join(coord_extra, by = "pol_id") %>%
  left_join(coord_sample_replaced, by = "pol_id_replaced") %>%
  mutate(distance_replaced = round(sqrt((x - x_replaced) ^ 2 + (y - y_replaced) ^ 2 ), 0))


replaced_2190 <- assessments_mhq_watersurfaces %>%
  filter(str_detect(note, c("verschuiving naar|verschoven naar"))) %>%
  mutate(code_inboveg_replacement = word(note, -1),
         code_inboveg_replacement = ifelse(!str_detect(code_inboveg_replacement, "WV"), str_c("WV_", code_inboveg_replacement),
                                           code_inboveg_replacement)) %>%
  filter(type_target_all == "2190") %>%
  select(code_inboveg = code_inboveg_replacement, pol_id_replaced = pol_id, grts_ranking_draw)

replacement_2190 <- assessments_mhq_watersurfaces %>%
  filter(str_detect(note, c("verschuiving van|verschoven van"))) %>%
  mutate(code_inboveg_replaced = word(note, -1)) %>%
  filter(set != "extra") %>%
  select(-grts_ranking_draw) %>%
  left_join(replaced_2190, by = "code_inboveg") %>%
  distinct() %>%
  mutate(replaced = TRUE) %>%
  left_join(coord_sample, by = "pol_id") %>%
  left_join(coord_sample_replaced, by = "pol_id_replaced") %>%
  mutate(distance_replaced = round(sqrt((x - x_replaced) ^ 2 + (y - y_replaced) ^ 2 ), 0))



replacement <- bind_rows(replacement_2190,
                         replacement_31xx)

```

The table below provides an overview of the replaced sampling units.

+ The target type of the original sampling unit should be the same as the observed type in the newly selected sampling unit. This is not the case for one sampling unit.
+ The table also provides the distance between reference points. 
+ For one sampling unit it could not be identified which sampling unit it replaces (NOD_011: to be checked!)

```{r}
replacement %>%
  select(code_watersurfaces, pol_id, pol_id_replaced, type_target_all, type_observed, "distance_replaced (m)" =  distance_replaced, note) %>%
  kable() %>%
  kable_styling()
```

We also check the admin data for the original sampling units. 
The table below shows that for most records the target type was not observed (is_type_target = FALSE), as expected.  
Only one sampling unit contains the target type and was measured, yet another sampling unit was selected nearby as a replacement. 
To be checked with field workers!

```{r}
replaced <- assessments_mhq_watersurfaces %>%
  filter(str_detect(note, "verschuiving naar|verschoven naar")) %>%
  mutate(pol_id_replacement = word(note, -1))

replaced %>%
  select(pol_id, pol_id_replacement, type_target_all, type_observed, is_type_target, year_biotic, note) %>%
  kable() %>%
  kable_styling()

```

```{r}
assessments_mhq_watersurfaces <- assessments_mhq_watersurfaces %>%
  anti_join(replacement, by = "pol_id") %>%
  bind_rows(select(replacement, -x, -y, -x_replaced, -y_replaced, -code_watersurfaces_replaced))

mhq_watersurfaces_refpoints <- mhq_watersurfaces_refpoints_orig %>%
  bind_rows(select(mhq_watersurfaces_refpoints_extra, pol_id, grts_ranking = grts_ranking_extra))
```

### Sampling units that are not accessible

Some sampling units can not be assessed since they are on private property and no access is provided.
For these sampling units we set the variable inaccessible to 'long term'. The variable is_type_target is set to NA.

```{r}

assessments_mhq_watersurfaces <- assessments_mhq_watersurfaces %>%
  mutate(inaccessible = ifelse(str_detect(note, "priv"), "long term", NA),
         is_type_target = ifelse(!is.na(inaccessible), NA, is_type_target),
         any_type_target = ifelse(!is.na(inaccessible), NA, any_type_target),
         assessment = ifelse(!is.na(inaccessible), FALSE, assessment))

```


### Sampling units that were not considered for assessment

When sampling units does not contain the target type new sampling units have to be selected based on the grts-ranking. 
In some cases it was decided not to assess a new sampling unit that should have been selected according to the grts-ranking. 
This because the new sampling unit was located in a region in which already sufficient sampling units were measured.

```{r}
assessments_mhq_watersurfaces %>%
  filter(str_detect(note, "te veel")) %>%
  select(pol_id, type_target_all, note) %>%
  kable() %>%
  kable_styling()
```

These sampling units are not assessed and therefore removed from the assessment admin table.

```{r}
assessments_mhq_watersurfaces <- assessments_mhq_watersurfaces %>%
  # filter(!str_detect(note, "te veel") | is.na(note)) 
  mutate(assessment = ifelse(str_detect(note, "te veel") & !is.na(note), FALSE, assessment),
         is_type_target = ifelse(str_detect(note, "te veel") & !is.na(note), NA, is_type_target),
         any_type_target = ifelse(str_detect(note, "te veel") & !is.na(note), NA, any_type_target))
```


## Defining the spatial extent of the sampling units more precisely

The initial sampling units were selected based on the habitatmap. 
The selected polygons did not always fully match with the actual watersurface and some polygons contain various watersurfaces.

Today we have the watersurface layer, which precisely locates all watersurfaces in Flanders.
We will use this layer to define the spatial extent of the sampling units. 
However we will keep the orignal reference points as these are used to assign the grts-ranking to each sapling unit.


```{r}

mhq_watersurfaces_samplingunits2 <- mhq_watersurfaces_samplingunits %>%
  st_join(watersurfaces) %>%
  left_join(select(assessments_mhq_watersurfaces, pol_id, code_watersurfaces_recorded = code_watersurfaces, assessment, inaccessible, measurement_biotic, measurement_abiotic), by = "pol_id") %>%
  group_by(pol_id) %>%
    mutate(n_overlap = n_distinct(code_watersurfaces)) %>%
  ungroup() 

check <- mhq_watersurfaces_samplingunits2 %>%
  group_by(code_watersurfaces) %>%
  mutate(n = n_distinct(type_target_all)) %>%
  ungroup() %>%
  filter(n> 1)
           
```

### Check measured 31xx watersurfaces

For types 31xx the code (from the watersurfaces data source) of the measured watersurface is recorded. 

```{r}
# measured 

check_measured_31xx <- mhq_watersurfaces_samplingunits2 %>%
  st_drop_geometry() %>%
  unique() %>%
  filter(!is.na(assessment)) %>%
  filter(type_target_all != "2190") %>%
  filter(measurement_biotic | measurement_abiotic) %>%
  mutate(check_code = code_watersurfaces == code_watersurfaces_recorded) %>%
  group_by(pol_id) %>%
  mutate(n_match_code = sum(check_code),
         n_overlap = n_distinct(code_watersurfaces)) %>%
  ungroup()

check_1measurement_per_samplingunit <- all((check_measured_31xx %>%
  filter(n_overlap > 1))$n_match_code == 1)
```

Several of the original sampling units contain more than one watersurface (defined by the watersurface data source).
If this is the case, only one of the watersurfaces is measured.
The spatial extent of the original sampling unit is replaced by the spatial extent of the measured watersurface.
However we keep the original reference point, as this point defines the grts-ranking on which the sample is based.
When a sampling unit contains more than one watersurfaces, we consider the watersurfaces that were not measured as not assessed.
This is because we do not know if the target type is present in these different watersurfaces. 
These watersurfaces have to be added to the sampling frame

The table below gives the distribution of the number of overlaps between the original sampling units and the watersurfaces.

```{r}
check_measured_31xx %>%
  distinct(pol_id, n_overlap) %>%
  group_by(n_overlap) %>%
  summarise(n_pol = n_distinct(pol_id)) %>%
  ungroup() %>%
  select("number of overlap with watersurfaces" = n_overlap, "number of sampling units" = n_pol) %>%
  kable() %>%
  kable_styling()
```

In the table below we list the polygons for which the recorded code does not correspond with the code of the overlapping watersurface.
In two cases the recorded code does not exist, so a recording error occured.
In two other cases the recorded code corresponds to a nearby watersurface, so a replacement was performed that was not documented.
We correct the codes, and we handle the replacements as specified above.


```{r}
wrong_code <- check_measured_31xx %>%
  filter(n_match_code == 0) %>%
  select(pol_id, code_watersurfaces, code_watersurfaces_recorded)  %>%
  mutate(code_recorded_exists = code_watersurfaces_recorded %in% watersurfaces$code_watersurfaces)

wrong_code %>%
  kable() %>%
  kable_styling()

```



```{r}

extra_replacement_refpoints <- watersurfaces %>%
  filter(code_watersurfaces %in% wrong_code$code_watersurfaces_recorded) %>%
  st_point_on_surface() %>%
  mutate(grts_ranking_extra = grts_master[as(., "Spatial")],
         pol_id = str_c("extra_", code_watersurfaces))

coords_extra_replacement <- extra_replacement_refpoints %>%
  st_drop_geometry() %>%
  mutate(x = st_coordinates(extra_replacement_refpoints)[, 1],
         y = st_coordinates(extra_replacement_refpoints)[, 2]) %>%
  select(pol_id, x, y)
  
replacement <- assessments_mhq_watersurfaces %>%
  select(-pol_id_replaced, -grts_ranking) %>%
  rename(pol_id_replaced = pol_id) %>%
  inner_join(st_drop_geometry(extra_replacement_refpoints), by = c("code_watersurfaces")) %>%
  rename(grts_ranking = grts_ranking_extra) %>%
  left_join(coords_extra_replacement, by = "pol_id") %>%
  left_join(coord_sample_replaced, by = "pol_id_replaced") %>%
  mutate(distance_replaced = sqrt((x - x_replaced)^2 + (y - y_replaced)^2),
         replaced = TRUE) %>%
  select(-x, -x_replaced, -y, -y_replaced)

correction <- wrong_code %>%
  select(pol_id, code_watersurfaces, replaced = code_recorded_exists)

replaced <- assessments_mhq_watersurfaces %>%
  select(-replaced, -code_watersurfaces) %>%
  inner_join(correction, by = c("pol_id")) %>%
  mutate(type_observed = ifelse(replaced, NA, type_observed),
         area_class_observed = ifelse(replaced, NA, as.character(area_class_observed)),
         year_abiotic = ifelse(replaced, NA, year_abiotic),
         year_biotic = ifelse(replaced, NA, year_biotic),
         measurement_abiotic = ifelse(replaced, FALSE, measurement_abiotic),
         measurement_biotic = ifelse(replaced, FALSE, measurement_biotic),
         is_type_target = ifelse(replaced, FALSE, is_type_target),
         any_type_target = ifelse(replaced, FALSE, any_type_target),
         note = ifelse(replaced, NA, note))
  
  
assessments_mhq_watersurfaces <- assessments_mhq_watersurfaces %>%
  anti_join(wrong_code, by = "pol_id") %>%
  bind_rows(replacement) %>%
  bind_rows(replaced)

mhq_watersurfaces_refpoints <- mhq_watersurfaces_refpoints %>%
  bind_rows(select(extra_replacement_refpoints, pol_id, grts_ranking = grts_ranking_extra))


```



### Assessed 31xx sampling units that did not contain the target type

For the sampling units that did not contain the target type, the watersurface code was not recorded. 
We derive the watersurface code by overlaying the original sampling units with the watersurfaces.
When a sampling unit contains several watersurfaces, we assume that all of these watersurfaces do not contain the target type.
In this case, we create a record for each watersurface and we derive a new refpoint and grts_ranking using point_on_surface.
We only select the watersurfaces that overlap for more than 50% with the original sampling unit.

```{r}
# not measured 

watersurfaces <- watersurfaces %>%
  mutate(area_ws = drop_units(st_area(geom)))

fraction_overlap <- mhq_watersurfaces_samplingunits %>%
  select(pol_id) %>%
  st_intersection(watersurfaces) %>%
  mutate(area_overlap = drop_units(st_area(geometry))) %>%
  st_drop_geometry() %>%
  group_by(pol_id, code_watersurfaces, area_ws) %>%
  summarise(area_overlap = sum(area_overlap)) %>%
  ungroup() %>%
  mutate(prop_overlap = area_overlap/area_ws)
  
check_visited_31xx <- mhq_watersurfaces_samplingunits2 %>%
  st_drop_geometry() %>%
  unique() %>%
  filter(!is.na(assessment)) %>%
  filter(!measurement_abiotic & !measurement_biotic) %>%
  filter(type_target_all != "2190") %>%
  group_by(pol_id) %>%
  mutate(n_overlap = n_distinct(code_watersurfaces)) %>%
  ungroup() %>%
  left_join(fraction_overlap, by = c("code_watersurfaces", "pol_id"))

watersurfaces_no_target_type <- check_visited_31xx %>%
  filter(n_overlap == 1 | (n_overlap > 1 & prop_overlap > 0.2)) %>%
  select(pol_id, code_watersurfaces) %>%
  filter(!is.na(code_watersurfaces))

watersurfaces_no_target_type_refpoints <- watersurfaces_no_target_type %>%
  left_join(watersurfaces, by = "code_watersurfaces") %>%
  st_as_sf() %>%
  st_point_on_surface() %>%
  mutate(grts_ranking = grts_master[as(., "Spatial")]) %>%
  select(pol_id, code_watersurfaces, grts_ranking)
  
assessments_watersurfaces_no_target_type <- assessments_mhq_watersurfaces %>%
  semi_join(watersurfaces_no_target_type, by = "pol_id") %>%
  select(-code_watersurfaces, -grts_ranking) %>%
  left_join(watersurfaces_no_target_type, by = "pol_id") %>%
  left_join(st_drop_geometry(watersurfaces_no_target_type_refpoints), by = c("pol_id", "code_watersurfaces"))

assessments_mhq_watersurfaces <- assessments_mhq_watersurfaces %>%
  anti_join(assessments_watersurfaces_no_target_type, by = "pol_id") %>%
  bind_rows(assessments_watersurfaces_no_target_type)

mhq_watersurfaces_refpoints <- mhq_watersurfaces_refpoints %>%
  filter(! pol_id %in% watersurfaces_no_target_type_refpoints$pol_id) %>%
  bind_rows(watersurfaces_no_target_type_refpoints)
```

### Assessed 2190 sampling units

For 2190 the watersurface code was not recorded during measurement.
However the sampling units almost fully match with the watersurfaces.
One polygon (WV_DHE_020) overlaps with 5 watersurface polygons: for now we assume that watersurface WVLBRD0089 is the correct watersurface: TO BE CHECKED!


```{r}
check_assessed_2190 <- mhq_watersurfaces_samplingunits2 %>%
  st_drop_geometry() %>%
  unique() %>%
  filter(!is.na(assessment) | !is.na(inaccessible)) %>%
  filter(type_target_all == "2190") %>%
  #filter(measurement_biotic | measurement_abiotic) %>%
  mutate(check_code = code_watersurfaces == code_watersurfaces_recorded) %>%
  group_by(pol_id) %>%
  mutate(n_match_code = sum(check_code),
         n_overlap = n_distinct(code_watersurfaces)) %>%
  ungroup()

check_1measurement_per_samplingunit <- all((check_measured_31xx %>%
  filter(n_overlap > 1))$n_match_code == 1)

no_overlap <- check_assessed_2190 %>%
  filter(is.na(code_watersurfaces))

add_code_2190 <- check_assessed_2190 %>%
  filter(n_overlap == 1 | code_watersurfaces == "WVLBRD0089") %>%
  select(pol_id, add_code_watersurfaces = code_watersurfaces) 

assessments_mhq_watersurfaces <- assessments_mhq_watersurfaces %>%
  left_join(add_code_2190, by = "pol_id") %>%
  mutate(code_watersurfaces = ifelse(!is.na(add_code_watersurfaces), add_code_watersurfaces, code_watersurfaces)) %>%
  select(-add_code_watersurfaces)
```

### Not assessed

We add the watersurface code to the sampling units that were not assessed.
If the original sampling unit contains more than one watersurface, we create a record for each sampling unit and recalculate the grts-ranking. The original grts-ranking is stored in grts_ranking_draw.

```{r}
check_not_assessed <- mhq_watersurfaces_samplingunits2 %>%
  st_drop_geometry() %>%
  unique() %>%
  filter(is.na(assessment) | !assessment) %>%
  filter(!is.na(code_watersurfaces)) %>%
  filter(set != "selection2014") %>%
  #filter(measurement_biotic | measurement_abiotic) %>%
  group_by(pol_id) %>%
  mutate(n_overlap_pol_id = n_distinct(code_watersurfaces)) %>%
  ungroup() %>%
  left_join(fraction_overlap, by = c("code_watersurfaces", "pol_id")) 

watersurfaces_not_assessed <- check_not_assessed %>%
  filter(n_overlap_pol_id == 1 | (n_overlap_pol_id > 1 & prop_overlap > 0.2)) %>%
  select(pol_id, code_watersurfaces, n_overlap_pol_id) %>%
  filter(!is.na(code_watersurfaces))

watersurfaces_not_assessed2 <- check_not_assessed %>%
  semi_join(admin_assessments_watersurfaces, by = "code_watersurfaces")

watersurfaces_not_assessed_overlap_refpoints <- watersurfaces_not_assessed %>%
  filter(n_overlap_pol_id > 1) %>%
  left_join(watersurfaces, by = "code_watersurfaces") %>%
  st_as_sf() %>%
  st_point_on_surface() %>%
  mutate(grts_ranking_new = grts_master[as(., "Spatial")]) %>%
  select(pol_id, code_watersurfaces, grts_ranking_new)
  
assessments_watersurfaces_not_assessed <- assessments_mhq_watersurfaces %>%
  semi_join(watersurfaces_not_assessed, by = "pol_id") %>%
  select(-code_watersurfaces) %>%
  left_join(watersurfaces_not_assessed, by = "pol_id") %>% #add code watersurfaces
  left_join(st_drop_geometry(watersurfaces_not_assessed_overlap_refpoints), by = c("pol_id", "code_watersurfaces")) %>%
  mutate(grts_ranking = ifelse(!is.na(grts_ranking_new), grts_ranking_new, grts_ranking)) %>%
  select(-grts_ranking_new, -n_overlap_pol_id)

assessments_mhq_watersurfaces <- assessments_mhq_watersurfaces %>%
  anti_join(check_not_assessed, by = "pol_id") %>%
  bind_rows(assessments_watersurfaces_not_assessed)

mhq_watersurfaces_refpoints <- mhq_watersurfaces_refpoints %>%
  filter(! pol_id %in% watersurfaces_not_assessed_overlap_refpoints$pol_id) %>%
  bind_rows(rename(watersurfaces_not_assessed_overlap_refpoints, grts_ranking = grts_ranking_new))

```



### Watersurfaces that contain two or more original sampling units

Some of the assessed watersurfaces contain two of the original sampling units. 
This can be the case when two watersurfaces were merged in the latest version of the watersurfaces data source (which we use as a reference for defining the sampling units).  
In this case the admin data contains two records for one watersurface, one for each of the original sampling units.
However, both records refer to the same assessment and can be aggregated to one record.
In this aggregation we set grts_ranking_draw to the minimum value of grts_ranking_draw for both original sampling units.
After aggregation we recalculate the grts_ranking based on the watersurface polygon using st_point_on_surface. 

```{r}

# double assessments per watersurface
check_double <- assessments_mhq_watersurfaces %>%
  filter(!is.na(code_watersurfaces)) %>%
  group_by(pol_id, code_watersurfaces, set, grts_ranking, grts_ranking_draw, type_target_all, assessment, year_biotic, year_abiotic, measurement_biotic, measurement_abiotic) %>%
    summarise(type_observed_all = str_c(type_observed, collapse = "; ")) %>%
  ungroup() %>%
  group_by(code_watersurfaces) %>%
    mutate(n = n()) %>%
  ungroup() %>%
  filter(n > 1)

assessments_mhq_watersurfaces_double <- assessments_mhq_watersurfaces %>%
  semi_join(check_double, by = "code_watersurfaces") %>%
  group_by(code_watersurfaces, type_target_all,  year_abiotic, year_biotic, type_observed, measurement_biotic, measurement_abiotic, code_inboveg_replaced, pol_id_replaced, distance_replaced) %>%
  summarise(assessment = any(assessment),
            inaccessible = ifelse(any(inaccessible == "long term"), "long term", NA),
            pol_id = str_c(pol_id, collapse = ";"),
            grts_ranking = min(grts_ranking),
            grts_ranking_draw = min(grts_ranking_draw),
            set = str_c(na.omit(unique(set)), collapse= ";"),
            monitoring_type = str_c(unique(monitoring_type), collapse= ";"),
            is_type_target = all(is_type_target),
            any_type_target = all(any_type_target),
            note = str_c(na.omit(note), collapse = ";"),
            replaced = any(replaced)) %>%
  ungroup() 

# still double assessments per watersurface because type_target_all is different

check_double2 <- assessments_mhq_watersurfaces_double %>%
  group_by(code_watersurfaces) %>%
  mutate(n = n()) %>%
  ungroup() %>%
  filter(n > 1)

assessments_mhq_watersurfaces_corr <- assessments_mhq_watersurfaces %>%
  filter(assessment) %>%
  select(-pol_id, -type_target_all, -is_type_target, -any_type_target) %>%
  distinct()

assessments_mhq_watersurfaces_double2 <- assessments_mhq_watersurfaces %>%
  semi_join(check_double2, by = "code_watersurfaces") %>%
  separate_rows(type_target_all, sep = ";") %>%
  arrange(type_target_all) %>%
  group_by(code_watersurfaces) %>%
  summarise(type_target_all = str_c(unique(type_target_all), collapse = ";"),
            pol_id = str_c(unique(pol_id), collapse = ";")) %>%
  ungroup() %>%
  left_join(assessments_mhq_watersurfaces_corr, by = "code_watersurfaces") %>%
  mutate(is_type_target = str_detect(type_target_all, type_observed),
         is_type_target = ifelse(is.na(type_observed), FALSE, is_type_target)) %>%
  group_by(code_watersurfaces) %>%
  mutate(any_type_target = any(is_type_target)) %>%
  ungroup()
  

assessments_mhq_watersurfaces_double3 <- assessments_mhq_watersurfaces_double %>%
  anti_join(assessments_mhq_watersurfaces_double2, by = "code_watersurfaces") %>%
  bind_rows(assessments_mhq_watersurfaces_double2)

check_double3 <- assessments_mhq_watersurfaces_double %>%
  group_by(code_watersurfaces, type_observed) %>%
  mutate(n = n()) %>%
  ungroup() %>%
  filter(n > 1)



# mhq_refpoints_double <-  assessments_mhq_watersurfaces_double3 %>%
#   distinct(pol_id, code_watersurfaces) %>%
#   group_by(code_watersurfaces) %>%
#   summarise(pol_id = str_c(pol_id, collapse = "; ")) %>%
#   ungroup() %>%
#   left_join(watersurfaces, by = "code_watersurfaces") %>%
#   st_as_sf() %>%
#   st_point_on_surface() %>%
#   mutate(grts_ranking = grts_master[as(., "Spatial")]) %>%
#   select(pol_id, code_watersurfaces, grts_ranking)
# 
# assessments_mhq_watersurfaces_double3 <- assessments_mhq_watersurfaces_double3 %>%
#   select(-grts_ranking) %>%
#   left_join(st_drop_geometry(select(mhq_refpoints_double, -pol_id)), by = c("code_watersurfaces"))

assessments_mhq_watersurfaces <- assessments_mhq_watersurfaces %>%
  anti_join(assessments_mhq_watersurfaces_double3, by = "code_watersurfaces") %>%
  bind_rows(assessments_mhq_watersurfaces_double3)

remove_refpoints_double <- check_double %>%
  anti_join(assessments_mhq_watersurfaces_double3, by = c("grts_ranking", "code_watersurfaces")) %>%
  select(pol_id, code_watersurfaces, grts_ranking, grts_ranking_draw)

mhq_watersurfaces_refpoints <- mhq_watersurfaces_refpoints %>%
  filter(! pol_id %in% remove_refpoints_double$pol_id)

```




## Standardize result

```{r}
watersurfaces_hab <- read_watersurfaces_hab()
types <- read_types()
```


```{r}
mhq_watersurfaces_objects <- assessments_mhq_watersurfaces %>%
  filter(!is.na(code_watersurfaces)) %>%
  distinct(code_watersurfaces, grts_ranking) %>%
  left_join(watersurfaces, by = "code_watersurfaces") %>%
  st_as_sf() %>%
  select(-area_ws)

check <- mhq_watersurfaces_objects %>%
  st_drop_geometry() %>%
  group_by(code_watersurfaces) %>%
  mutate(n = n()) %>%
  ungroup() %>%
  filter(n > 1)

check_geom <- !any(st_is_empty(mhq_watersurfaces_objects$geom))

check_geom <- mhq_watersurfaces_objects %>%
  filter(!st_is(mhq_watersurfaces_objects$geom, "POLYGON"))

add_code_watersurfaces <- assessments_mhq_watersurfaces %>%
  filter(!is.na(code_watersurfaces)) %>%
  distinct(pol_id, code_watersurfaces, grts_ranking) 

mhq_watersurfaces_refpoints2 <- mhq_watersurfaces_refpoints %>%
  filter(is.na(code_watersurfaces)) %>%
  select(-code_watersurfaces) %>%
  inner_join(add_code_watersurfaces, by = c("grts_ranking", "pol_id")) %>%
  group_by(grts_ranking, code_watersurfaces) %>%
  summarise(pol_id = str_c(unique(pol_id), collapse = ";")) %>%
  ungroup() 

mhq_watersurfaces_refpoints3 <- mhq_watersurfaces_refpoints %>%
  filter(!is.na(code_watersurfaces)) %>%
  bind_rows(mhq_watersurfaces_refpoints2) %>%
  st_join(select(mhq_watersurfaces_objects, code_watersurfaces_check = code_watersurfaces)) %>%
  mutate(in_object = !is.na(code_watersurfaces_check) & code_watersurfaces_check == code_watersurfaces) %>%
  select(-code_watersurfaces_check) 
# 
check <- mhq_watersurfaces_refpoints3 %>%
  group_by(code_watersurfaces) %>%
  mutate(n = n()) %>%
  ungroup() %>%
  filter(n > 1)

check_geom <- mhq_watersurfaces_refpoints3 %>%
  filter(!st_is(mhq_watersurfaces_refpoints3$geom, "POINT"))

check_objects <- mhq_watersurfaces_objects %>%
  filter(! code_watersurfaces %in% mhq_watersurfaces_refpoints3$code_watersurfaces)

check_wc_code <- mhq_watersurfaces_refpoints3 %>%
  rename(polygon_id = code_watersurfaces) %>%
  anti_join(watersurfaces_hab$watersurfaces_types, by = "polygon_id")

watersurfaces_refpoints <- mhq_watersurfaces_refpoints3 %>%
  st_drop_geometry() %>%
  mutate(x = round(st_coordinates(mhq_watersurfaces_refpoints3)[,1], 2),
         y = round(st_coordinates(mhq_watersurfaces_refpoints3)[,2], 2)) %>%
  select(polygon_id = code_watersurfaces, grts_ranking, in_object, x, y)

write_vc(watersurfaces_refpoints, "watersurfaces_refpoints", "../output", sorting = "polygon_id", strict = FALSE)
```

+ watersurfaces_refpoints (git2rdata object): defines the reference point for the selected watersurfaces in the watersurfaces data source and grts-ranking for this refpoint
  + polygon_id: the id of the watersurface according to the data source `watersurfaces_hab`
  + grts_ranking
  + in_object: is the reference point located within the watersurface
  + x: x-coordinate (crs = 31370)
  + y: y-coordinate (crs = 31370)

```{r}
watersurfaces_refpoints %>%
  slice(1:5)
```


```{r, eval = FALSE}
mhq_watersurfaces_objects %>%
  select(code_watersurfaces, grts_ranking) %>%
  st_write("../output/watersurfaces_objects.gpkg")

 watersurfaces_refpoints %>%
  write_vc(file = "watersurfaces_refpoints", root = "../output" , sorting = c("grts_ranking", "code_watersurfaces"))

mhq_watersurfaces_refpoints3 %>%
  st_drop_geometry() %>%
  select(pol_id, code_watersurfaces) %>%
  st_write(dsn = "../output/mhq_watersurfaces_original.gpkg", layer = "link_samplinunits_watersurfaces", delete_layer = TRUE)
  

```


+ watersurfaces_assessments: table with assessment for the monitoring habitat quality programme
  + assessment_date: date of the assessment
    + Only the year was recorded, not the exact date. We convert the date to `year-01-01`
    + If the target type was not observed, the assessment year was not recorded. In this case we take the median of the years in which the assessments took place.
  + polygon_id: the id of the watersurface according to the data source `watersurfaces_hab` and/or `watersurfaces`
  + type: the evaluated type (one polygon can contain more than one type)
  + is_present: 
    + `TRUE` if the evaluated type was observed
    + `FALSE` if the evaluated type was not observed
    + `NA` if no assessment could be performed (watersurface is inaccessible) or if the type's presence is unknown
  + any_habitat: 
    + `TRUE` if any habitat type was observed
    + `FALSE` when the evaluated type is absent and also all other habitat types are absent (recorded as `gh`), altough a regional import biotope (rib) type might be present (the presence of rib types was not evaluated)
    + `NA` when the evaluated type is absent but it is not known if any other type is present (recorded as `doelhabitat` = `nee`)
  + assessment_source: field assessment or orthophoto
  + inaccessible: long term or short term

```{r}

mhq_watersurfaces_overview <- assessments_mhq_watersurfaces %>%
  filter(!is.na(assessment)) %>% 
  filter(assessment | !is.na(inaccessible)) %>%
  mutate(year_biotic = ifelse(year_biotic == 0, NA, year_biotic),
         assessment_year = pmin(year_abiotic, year_biotic, na.rm = TRUE),
         assessment_year = ifelse(is.na(assessment_year), median(assessment_year, na.rm = TRUE), assessment_year),
         assessment_date = as.Date(str_c(assessment_year, "-01-01"))) %>%
  mutate(assessment_source = ifelse(!is.na(assessment) & assessment, "field assessment", NA)) %>%
  select(pol_id, code_watersurfaces, type_target_all, type_observed, assessment_source, assessment_year, assessment_date, inaccessible, is_type_target, measurement_biotic, measurement_abiotic, measurement_biotic_year = year_biotic, measurement_abiotic_year = year_abiotic, db_ref = code_inboveg) %>%
  unique()

check_unique <- mhq_watersurfaces_overview %>%
  group_by(code_watersurfaces, type_observed) %>%
  mutate(n = n()) %>%
  ungroup() %>%
  filter(n > 1)

check_no_ws_code <- mhq_watersurfaces_overview %>%
  filter(is.na(code_watersurfaces)) %>%
  distinct(pol_id, type_target_all) %>%
  left_join(select(mhq_watersurfaces_samplingunits, pol_id), by = "pol_id") %>%
  st_as_sf() %>%
  st_join(watersurfaces_hab$watersurfaces_polygons) %>%
  st_drop_geometry() %>%
  select(pol_id, polygon_id) %>%
  filter(!is.na(polygon_id))

mhq_watersurfaces_overview <- mhq_watersurfaces_overview %>%
  left_join(check_no_ws_code, by = "pol_id") %>%
  mutate(code_watersurfaces = ifelse(is.na(code_watersurfaces), as.character(polygon_id), code_watersurfaces)) %>%
  filter(!is.na(code_watersurfaces)) %>%
  select(-polygon_id) %>%
  mutate(type_observed = ifelse(type_observed == "2190", "2190_a", type_observed),
         type = ifelse(type_observed %in% c("gh", "unknown"), NA, type_observed),
         type = factor(type_observed, levels = levels(types$type)),
         any_habitat = !is.na(type),
         any_habitat = ifelse(type_observed == "unknown" & !is.na(type_observed), NA, any_habitat))


type_present <- mhq_watersurfaces_overview  %>%
  filter(!is.na(type)) %>%
  mutate(is_present = TRUE) %>%
  select(assessment_date, polygon_id = code_watersurfaces, type, is_present, any_habitat, assessment_source, inaccessible) %>%
  arrange(assessment_date, polygon_id, type)
  
type_absent <- mhq_watersurfaces_overview %>%
  group_by(code_watersurfaces, type_target_all, assessment_source, assessment_date, inaccessible) %>%
  arrange(type_observed) %>%
  summarise(type_observed_all = str_c(type_observed, collapse = ";")) %>%
  ungroup() %>%
  separate_rows(type_target_all, sep = ";") %>%
  rename(type_target = type_target_all) %>%
  mutate(is_type_target = str_detect(string = type_observed_all, pattern =  type_target)) %>%
  filter(!is_type_target | is.na(is_type_target)) %>%
  filter(!is.na(type_target)) %>%
  mutate(is_present = ifelse(is.na(inaccessible), FALSE, NA),
         any_habitat = ifelse(type_observed_all == "gh", FALSE, NA),
         type = ifelse(type_target == "2190", "2190_a", type_target),
         type = factor(type, levels = types$type)) %>%
  select(assessment_date, polygon_id = code_watersurfaces, type, is_present, any_habitat, assessment_source, inaccessible)

mhq_watersurfaces_assessments <- bind_rows(type_present,
                                           type_absent) %>%
   arrange(assessment_date, polygon_id, type)
  
  

check_wc_code <- mhq_watersurfaces_assessments %>%
  anti_join(watersurfaces_hab$watersurfaces_types, by = "polygon_id")

mhq_watersurfaces_assessments %>%
  write_vc(file = "mhq_watersurfaces_assessments", root = "../output", sorting = c("assessment_date", "polygon_id", "type"), strict = FALSE)

```

```{r}
mhq_watersurfaces_assessments %>%
  slice(1:5)
```

+ mhq_watersurfaces_measurements: table with information on measurements
  + measurement_date: 
    + Only the year was recorded, not the exact date. We convert the date to `year-01-01`. Exact date could be extracted from the INBOVEG database?
  + polygon_id: the id of the watersurface according to the data source `watersurfaces_hab` and/or `watersurfaces`
  + db_ref: reference to record in INBOVEG database
  + type: the observed type (a watersurface can contain more than one type, so we can have more than one record for each assessment_date/polygon_id combination)
  + measurement_type: abiotic or biotic


```{r}

mhq_watersurfaces_measurements <- mhq_watersurfaces_overview %>%
  filter(measurement_abiotic | measurement_abiotic) %>%
  select(code_watersurfaces, db_ref , type,  type_observed, measured_biotic = measurement_biotic, measured_abiotic = measurement_abiotic, year_biotic = measurement_biotic_year, year_abiotic = measurement_abiotic_year) %>%
    pivot_longer(cols = c(measured_biotic, measured_abiotic, year_biotic, year_abiotic),
                 names_to = c(".value", "measurement_type"),
                 names_sep = "_") %>%
  filter(measured) %>%
  mutate(measurement_date = as.Date(str_c(year, "-01-01")),
         measurement_type = factor(measurement_type)) %>%
  select(measurement_date, polygon_id = code_watersurfaces, db_ref, measurement_type, type) %>%
  arrange(measurement_date, polygon_id, measurement_type, type)

mhq_watersurfaces_measurements %>%
  write_vc(file = "mhq_watersurfaces_measurements", root = "../output", sorting = c("measurement_date", "polygon_id", "measurement_type", "type"), strict = FALSE)
```

```{r}
mhq_watersurfaces_measurements %>%
  slice(1:5)
```

+ mhq_watersurfaces_populationunits: table with information on mhq population units from which sampling units are drawn
  + scheme: name of the monitoring scheme
  + sampling_unit_code: code for the sampling unit consisting of the polygon_id and the target type 
  + polygon_id
  + grts_ranking: grts_ranking associated with the reference point of the watersurface/sampling unit
  + grts_ranking_draw: the grts_ranking based on which the watersurface/sampling unit was selected
  + type_target: the type for which the sampling unit was selected
  + source_samplingunit: distinguishes between 
    + 'original sampling frame'
    + 'assessment cycle 1'
  
  
```{r}
types <- read_types() %>%
    select(main_type, type, type_shortname, typeclass_name)

schemes_mhq <- read_scheme_types() %>%
    select(scheme, type) %>%
    filter(str_sub(scheme, 1, 2) == "HQ") %>%
    left_join(types, by = "type") %>%
    select(scheme, type)

mhq_watersurfaces_populationunits_typetarget <- assessments_mhq_watersurfaces %>%
  filter(is_type_target) %>%
  mutate(type_observed = ifelse(type_observed == "2190", "2190_a", type_observed)) %>%
  mutate(type = factor(type_observed, levels = types$type)) %>%
  left_join(schemes_mhq, by = "type") %>%
  select(scheme, pol_id, code_watersurfaces, type, grts_ranking, grts_ranking_draw) %>%
  mutate(source = "original sample frame/assessments monitoring cycle 1")

mhq_watersurfaces_populationunits_notassessed <- assessments_mhq_watersurfaces %>%
  filter(!assessment| is.na(assessment)) %>%
  separate_rows(type_target_all, sep= ";") %>%
  mutate(type_target_all = ifelse(type_target_all == "2190", "2190_a", type_target_all)) %>%
  mutate(type = factor(type_target_all, levels = types$type)) %>%
  left_join(schemes_mhq, by = "type") %>%
  select(scheme, pol_id, code_watersurfaces, type, grts_ranking, grts_ranking_draw) %>%
  mutate(source = "original sample frame")

mhq_watersurfaces_populationunits_new <- assessments_mhq_watersurfaces %>%
  filter(measurement_biotic | measurement_abiotic) %>%
  filter(!is_type_target) %>%
  filter(type_observed %in% mhq_watersurfaces_populationunits_typetarget$type) %>%
  mutate(type_observed = ifelse(type_observed == "2190", "2190_a", type_observed)) %>%
  mutate(type = factor(type_observed, levels = types$type),
         grts_ranking_draw = ifelse(is.na(grts_ranking_draw), grts_ranking, grts_ranking_draw)) %>%
  left_join(schemes_mhq, by = "type") %>%
  select(scheme, pol_id, code_watersurfaces, type, grts_ranking, grts_ranking_draw) %>%
  mutate(source = "assessments monitoring cycle 1")

mhq_watersurfaces_populationunits <- mhq_watersurfaces_populationunits_typetarget %>%
  bind_rows(mhq_watersurfaces_populationunits_new) %>%
  bind_rows(mhq_watersurfaces_populationunits_notassessed) 

check_no_ws_code <- mhq_watersurfaces_populationunits %>%
  filter(is.na(code_watersurfaces)) %>%
  distinct(pol_id) %>%
  left_join(select(mhq_watersurfaces_samplingunits, pol_id), by = "pol_id") %>%
  st_as_sf() %>%
  st_join(watersurfaces_hab$watersurfaces_polygons, largest = TRUE) %>%
  st_drop_geometry() %>%
  select(pol_id, polygon_id) %>%
  filter(!is.na(polygon_id))

mhq_watersurfaces_populationunits <- mhq_watersurfaces_populationunits %>%
  left_join(check_no_ws_code, by = "pol_id") %>%
  mutate(polygon_id = ifelse(is.na(code_watersurfaces), as.character(polygon_id), code_watersurfaces)) %>%
  group_by(scheme, polygon_id, type, grts_ranking) %>%
  summarise(grts_ranking_draw = min(grts_ranking_draw),
            source = ifelse(any(source == "original sample frame"),
                                             "original sample frame", unique(source))) %>%
  ungroup() %>%
  mutate(sampling_unit_code = str_c(polygon_id, type, sep = "_")) %>%
  select(scheme, sampling_unit_code, polygon_id, everything()) %>%
  filter(!is.na(polygon_id)) %>%
  arrange(type, grts_ranking_draw, polygon_id)



check <- mhq_watersurfaces_populationunits %>%
  group_by(scheme, sampling_unit_code) %>%
  mutate(n = n()) %>%
  ungroup() %>%
  filter(n > 1)

mhq_watersurfaces_populationunits %>%
  write_vc(file = "mhq_watersurfaces_populationunits", root = "../output", sorting = c('type', 'grts_ranking_draw', 'polygon_id'), strict = FALSE)
```

```{r}
mhq_watersurfaces_populationunits %>%
  slice(1:5, 400:405)
```


```{r, eval=FALSE}
mhq_watersurfaces_objects %>%
  st_transform(4326) %>%
  leaflet() %>%
  addTiles() %>%
  addPolygons(popup = ~str_c("code_ws: ", code_watersurfaces), group = "objects") %>%
  addCircleMarkers(data = st_transform(mhq_watersurfaces_refpoints3, 4326), 
                   label = ~str_c("pol_id: ", pol_id, "code_ws: ", code_watersurfaces), group = "refpoints",
                   color = ~ifelse(in_object, "green", "red")) %>%
  addLayersControl(overlayGroups = c("objects", "refpoints"))
```