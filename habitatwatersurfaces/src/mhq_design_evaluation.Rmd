

---
title: "Design and evaluation of monitoring habitat quality scheme for watersurfaces"
# subtitle: "x"
date: "`r lubridate::now()`"
link-citations: true
linkcolor: link.colour
citecolor: link.colour
urlcolor: link.colour
geometry: margin=1in
mainfont: "Calibri"
fontsize: 11pt
documentclass: "article"
# csl: ../inbo.csl
# bibliography: ../references.bib
site: bookdown::bookdown_site
output:
  bookdown::html_document2:
    keep_md: TRUE
    number_sections: yes
    fig_caption: yes
    df_print: paged
    code_folding: hide
    toc: TRUE
    toc_float:
      collapsed: FALSE
      smooth_scroll: FALSE
  bookdown::pdf_document2:
    fig_caption: yes
    keep_tex: yes
    toc: yes
    toc_depth: 3
    latex_engine: xelatex
    number_sections: true
    includes:
        in_header: ../header.tex
---

```{r setup, include=FALSE}
library(knitr)
opts_chunk$set(
  echo = TRUE,
  cache = TRUE ,
  warning = FALSE,
  message = FALSE
)

# remotes::install_github("inbo/n2khab",
#                         ref = "dev_0.5.0")
options(rgdal_show_exportToProj4_warnings = "none")
options(stringsAsFactors = FALSE,
        scipen = 999, 
        digits = 15)
library(sf)
library(git2rdata)
library(stars)
library(raster)
library(tidyverse)
library(n2khab)
library(kableExtra)
library(units)
library(leaflet)
library(units)
library(renv)
library(readxl)
library(INBOtheme)
library(inbodb)

options(stringsAsFactors = FALSE)

```







<!--chapter:end:index.Rmd-->


# Read original mhq sample for watersurfaces

## Selected sampling units in 2014

In 2014 the an initial sample was drawn based in the habitatmap version 2014.
The sampling unit corresponds to a polygon of the habitatmap.
A GRTS ranking was asigned to every polygon based on [GRTSmaster_habitats](https://zenodo.org/record/2682323).
The centroid of the polygon was used to link the polygon to a GRTS raster cell.
So we can regard the centroid of the polygon as the 'reference point' of the sampling unit

The files can be found in [this google drive folder](https://drive.google.com/drive/folders/1j-CbsuF6vTQJ3weT6gJWTV1nVhxWmfX7).

```{r}
# shapefile with polygons
sample_2014_orig <- read_sf("../data/watersurfaces_2014/steekproef2014.shp", crs = 31370)

sample_2014_sf <- sample_2014_orig %>%
  select(pol_id = Pol_ID, sac = SBZH, type_target = doelhabt) %>%
  mutate(sac = ifelse(is.na(sac), 0, sac)) %>%
  group_by(pol_id, sac) %>%
  summarise(type_target_all = str_c(type_target, collapse = " + ")) %>%
  ungroup() %>%
  mutate(pol_id = as.character(pol_id))

# text file with sampling units
sample_3130_aom <- read.table("../data/watersurfaces_2014/meetnet3130_aom_20140324.txt", ) 
sample_3130_na <- read.table("../data/watersurfaces_2014/meetnet3130_na_20140324.txt") 
sample_3140 <- read.table("../data/watersurfaces_2014/meetnet3140_20140324.txt") %>%
  mutate(code = as.character(code))
sample_3150 <- read.table("../data/watersurfaces_2014/meetnet3150_20140324.txt")  %>%
  mutate(code = as.character(code))
sample_3160 <- read.table("../data/watersurfaces_2014/meetnet3160_20140324.txt")%>%
  mutate(code = as.character(code))

sample_2014 <- bind_rows(sample_3130_aom,
                         sample_3130_na,
                         sample_3140,
                         sample_3150,
                         sample_3160) %>%
  filter(steekproef == 1) %>%
  select(pol_id = Pol_ID, sac = SBZH, type_target = code, phab, area_class = Opp_klasse, grts_ranking = Ranking, ranking_rel = rangnr) %>%
  mutate(set = "selection2014",
    area_class = ifelse(area_class == "(0,1e+04]", "Opp <= 1 ha",
                             ifelse(area_class == "(1e+04,5e+04]", "1 ha < Opp <= 5 ha",
                                    ifelse(area_class == "(5e+04,1e+05]", "5 ha < Opp < 50 ha",
                                           ifelse(area_class == "(1e+05,2.5e+05]", "5 ha < Opp < 50 ha",
                                                  ifelse(area_class == "(2.5e+05,5e+05]", "5 ha < Opp < 50 ha", NA))))),
    area_class = factor(area_class, levels = c("Opp <= 1 ha", "1 ha < Opp <= 5 ha", "5 ha < Opp < 50 ha"))) %>%
  mutate(pol_id = as.character(pol_id))

sample_2014_ranking <- sample_2014 %>%
  distinct(pol_id, grts_ranking)

sample_2014_sf <- sample_2014_sf %>%
  left_join(sample_2014_ranking, by = "pol_id") %>%
  mutate(set = "selection2014")

check_pol_id <- all.equal((sample_2014_sf %>%
                      arrange(pol_id))$pol_id,
                    (sample_2014 %>%
                      arrange(pol_id))$pol_id %>%
                      unique())
```

### Reproduce grts_ranking

```{r}
grts_master <- read_GRTSmh()

sample_2014_ranking_centroid <- sample_2014_sf %>%
  st_centroid() %>%
  mutate(grts_ranking_centroid = grts_master[as(., "Spatial")])

check_ranking <- sample_2014_ranking_centroid %>%
  filter(grts_ranking != grts_ranking_centroid)

```

```{r}
# read original refpoint data

refpoint_3130_aom <- read_sf("../data/watersurfaces_2014/meetnet_3130_aom_versie20140324.shp") %>%
  st_drop_geometry() %>%
  select(pol_id = Pol_ID, x_centroid = centroidX, y_centroid = centroidY) 

refpoint_3130_na <- read_sf("../data/watersurfaces_2014/meetnet_3130_na_versie20140324.shp") %>%
  st_drop_geometry() %>%
  select(pol_id = Pol_ID, x_centroid = centroidX, y_centroid = centroidY) 

refpoint_3140 <- read_sf("../data/watersurfaces_2014/meetnet_3140_versie20140324.shp") %>%
  st_drop_geometry() %>%
  select(pol_id = Pol_ID, x_centroid = centroidX, y_centroid = centroidY) 

refpoint_3150 <- read_sf("../data/watersurfaces_2014/meetnet_3150_versie20140324.shp") %>%
  st_drop_geometry() %>%
  select(pol_id = Pol_ID, x_centroid = centroidX, y_centroid = centroidY)

refpoint_3160 <- read_sf("../data/watersurfaces_2014/meetnet_3160_versie20140324.shp") %>%
  st_drop_geometry() %>%
  select(pol_id = Pol_ID, x_centroid = centroidX, y_centroid = centroidY)

sample_2014_refpoint <- bind_rows(refpoint_3130_aom, refpoint_3130_na, refpoint_3140, refpoint_3150, refpoint_3160) %>%
  unique() %>%
  mutate(x_refpoint = x_centroid,
         y_refpoint = y_centroid) %>%
  st_as_sf(coords = c("x_centroid", "y_centroid"), crs = 31370) %>%
  mutate(grts_ranking = grts_master[as(., "Spatial")],
         pol_id = as.character(pol_id))

```

```{r}
ranking_refpoint <- sample_2014_refpoint %>%
  st_drop_geometry() %>%
  rename(grts_ranking_refpoint = grts_ranking)

sample_2014_ranking_centroid_check <- sample_2014_ranking_centroid %>%
  left_join(ranking_refpoint, by = "pol_id") %>%
  filter(grts_ranking != grts_ranking_centroid)
  
```

For 5 sampling units the originally determined grts-ranking differs from the reproduced grts-ranking.

+ the grts-ranking were switched for the polygons with pol_id 5083 and 16115 due to a manual error

+ different centroids were obtained for polygons with pol_id 19114, 19877, and 51206 (three polygons with 'islands')

Below an example for polygon wit pol_id = 19144.
The red is the originally calculated centroid, the blue dot the currently derived centroid.

```{r}
pol_different_centroid <- c("19114", "19877", "51206")

show_polygons <- sample_2014_sf %>%
  filter(pol_id == "19114") 

show_centroids <- sample_2014_ranking_centroid %>%
  filter(pol_id == "19114") 

show_refpoints <- sample_2014_refpoint %>%
  filter(pol_id == "19114") 

show_polygons %>%
ggplot() +
  geom_sf() +
  geom_sf(data = show_centroids,
          colour = "blue", size = 4) +
  geom_sf(data = show_refpoints,
          colour = "red", size = 4)
 

```

We will set the grts-ranking of the sampling units to the currently determined rankings.
We will use the variable grts_ranking_draw to document on which grts-ranking the sample was based. 
So for 5 sampling units grts_ranking_draw will differ from grts_ranking.

```{r}
refpoints_2014 <- sample_2014_ranking_centroid %>%
  select(pol_id, grts_ranking = grts_ranking_centroid)

polygons_2014 <- sample_2014_sf %>%
  rename(grts_ranking_draw = grts_ranking) %>%
  left_join(st_drop_geometry(refpoints_2014), by = "pol_id") %>%
  select(pol_id, sac, type_target_all, grts_ranking, grts_ranking_draw, set) 

sample_2014 <- sample_2014 %>%
  rename(grts_ranking_draw = grts_ranking) %>%
  left_join(st_drop_geometry(refpoints_2014), by = "pol_id") %>%
  mutate(source_polygon = "habitatmap")

```



### Overview of number of sampling units per strata

```{r}
overzicht_sample_2014 <- sample_2014 %>%
  group_by(type_target, sac, area_class) %>%
  summarise(samplesize = n_distinct(pol_id)) %>%
  ungroup()
```
```{r}
overzicht_sample_2014 %>%
  spread(area_class, samplesize, fill = 0) %>%
  kable() %>%
  kable_styling()
```


## Available extra sampling units in 2016

In 2016 it appeared that the selected sampling units in 2014 were not sufficient to reach the desired sample size.
Additional sampling units were selected based on a preliminary version of the watersurfaces layer and the habitatmap version 2016.
Since then, a sampling unit corresponds to a polygon of the watersurfaces layer.
All watersurfaces that overlap with habitatmap polygons with 31xx habitat were selected, excluding habitatmap polygons in the 2014 sample that were already assessed in the field.
We drew also a sample for 2190_a by selecting all watersurfaces in habitatmap polygons that contain dune habitat, manually excluding some artificial watersurfaces that cleary dit not correspond with 2190_a. 

The files can be found in [this google drive folder](https://drive.google.com/drive/folders/1hXMgjTbiPWIgUv4cV3taNPRqAu7if1LS).

```{r}
sampleframe_31xx_2016_sf_orig <- read_sf("../data/watersurfaces_2016/Steekproef_31xx_extra_versie20160531.shp", crs = 31370)

sampleframe_31xx_2016_orig <- read_csv2("../data/watersurfaces_2016/Steekproef_31xx.csv")

sampleframe_2190_sf_orig <- read_sf("../data/watersurfaces_2016/Steekproefkader_2190_versie20170606.shp", crs = 31370) 

sampleframe_31xx_2016 <- sampleframe_31xx_2016_orig %>%
  select(pol_id = ID_Plas, type_target = Habsubt, sac = SBZH, area_class = OppKlasse, grts_ranking = Ranking, ranking_rel = RangNr, source_polygon = Type) %>%
  mutate(set = "selection2016",
         source_polygon = ifelse(source_polygon == "Polygoon blauwe laag", "watersurfaces", 
                                 ifelse(source_polygon == "Polygoon habitatkaart", "habitatmap", NA)))

polygon_id_type_target_all <- sampleframe_31xx_2016 %>%
  group_by(pol_id) %>%
  summarise(type_target_all = str_c(type_target, collapse = " + ")) %>%
  ungroup()

sampleframe_31xx_2016_sf <- sampleframe_31xx_2016_sf_orig %>%
  select(pol_id = ID_Plas,  grts_ranking = Ranking, sac = SBZH) %>%
  mutate(sac = as.numeric(sac)) %>%
  left_join(polygon_id_type_target_all, by = "pol_id") %>%
  mutate(set = "selection2016")

sampleframe_2190 <- sampleframe_2190_sf_orig %>%
  st_drop_geometry() %>%
  mutate(type_target = "2190") %>%
  select(pol_id = ID_plas, type_target, sac = SBZH, area_class = OppKlasse, grts_ranking = Ranking, ranking_rel = Volgorde) %>%
  mutate(set = "selection2016") %>%
  mutate(pol_id = as.character(pol_id),
         area_class = ifelse(area_class != "1 ha < Opp <= 5 ha", "Opp <= 1 ha", area_class),
         source_polygon = "watersurfaces")

sampleframe_2190_sf <- sampleframe_2190_sf_orig %>%
  mutate(type_target_all = "2190") %>%
  select(pol_id = ID_plas, grts_ranking = Ranking, sac = SBZH, type_target_all, selected = Steekproef) %>%
  mutate(pol_id = as.character(pol_id),
         set = "selection2016")
  
```



### Reproduce grts-ranking

We used the point_on_surface function to select reference points for the sampling units.
The reference points are used to assign a grts_ranking to each sampling unit.

```{r}
sampleframe_2016_ranking_refpoint <- sampleframe_31xx_2016_sf %>%
  bind_rows(sampleframe_2190_sf) %>%
  st_point_on_surface() %>%
  mutate(grts_ranking_refpoint = grts_master[as(., "Spatial")])

check_ranking <- sampleframe_2016_ranking_refpoint %>%
  filter(grts_ranking != grts_ranking_refpoint)

check_ranking_2190 <- check_ranking %>%
  mutate(rank_correct = rank(grts_ranking_refpoint),
         selection_correct = rank_correct <= 60)

sum(check_ranking_2190$selected == 1 & check_ranking_2190$selection_correct)
```

When reproducing the grts-ranking we find

+ a different grts_ranking for 5 sampling units selected for 31xx habitat types

+ a wrong grts_ranking for 2190 sampling units (reading the shape file with grts-ranking values converted the grts-ranking values to factor levels)

We will use the variable grts_ranking_draw to indicate the originally used grts-ranking for drawing the sample.

```{r}
refpoints_2016 <- sampleframe_2016_ranking_refpoint %>%
  select(pol_id, grts_ranking = grts_ranking_refpoint)

polygons_2016 <- sampleframe_31xx_2016_sf %>%
  bind_rows(sampleframe_2190_sf) %>%
  rename(grts_ranking_draw = grts_ranking) %>%
  left_join(st_drop_geometry(refpoints_2016), by = "pol_id") %>%
  select(pol_id, sac, type_target_all, grts_ranking, grts_ranking_draw, set) 

sampleframe_2016 <- sampleframe_31xx_2016%>%
  bind_rows(sampleframe_2190) %>%
  rename(grts_ranking_draw = grts_ranking) %>%
  left_join(st_drop_geometry(refpoints_2016), by = "pol_id") %>%
  mutate(area_class = ifelse(area_class == "> 50 ha", "Opp >= 50 ha", area_class),
         area_class = factor(area_class, levels = c("Opp <= 1 ha", "1 ha < Opp <= 5 ha", "5 ha < Opp < 50 ha", "Opp >= 50 ha"))) 

```

Below the selected sampling units for 2190_a (yellow polygons) and the other sampling units of the sampling frame (red polygons) that are not selected. Dispite the use of an incorrect grts-ranking, selected sampling units seem quite well distrubted at first sight.  

```{r}
sampleframe_2190_sf_orig %>%
  st_transform(4326) %>%
  mutate(color_show = ifelse(Steekproef == 1, "yellow", "red")) %>%
  leaflet() %>%
  addTiles() %>%
  addPolygons(color = ~color_show)
```
### Overview of number of sampling units per strata

```{r}
sampleframe_2016 %>%
  group_by(type_target, sac, area_class) %>%
  summarise(samplesize = n_distinct(pol_id)) %>%
  ungroup() %>%
  spread(area_class, samplesize, fill = 0) %>%
  kable() %>%
  kable_styling()
```

## Combine sample 2014 and sampleframe 2016

We combine the selected sampling units in 2014 and the sampling units of the sampleframe in 2016.

```{r}
mhq_watersurfaces_samplingunits <- polygons_2014 %>%
  bind_rows(polygons_2016) %>%
  mutate(sac = as.logical(sac))

mhq_watersurfaces_types <- sample_2014 %>%
  bind_rows(sampleframe_2016) %>%
  mutate(sac = as.logical(sac),
         area_class = ifelse(area_class == "> 50 ha", "Opp >= 50 ha", as.character(area_class)),
         area_class = factor(area_class, levels = c("Opp <= 1 ha", "1 ha < Opp <= 5 ha", "5 ha < Opp < 50 ha", "Opp >= 50 ha")))

mhq_watersurfaces_refpoints <- refpoints_2014 %>%
  bind_rows(refpoints_2016)


check_unique_pol_id <- nrow(mhq_watersurfaces_samplingunits) == n_distinct(mhq_watersurfaces_samplingunits$pol_id)
check_unique_ranking <- nrow(mhq_watersurfaces_samplingunits) == n_distinct(mhq_watersurfaces_samplingunits$grts_ranking)
check_types <- mhq_watersurfaces_types %>%
  group_by(pol_id, type_target) %>%
  mutate(n = n()) %>%
  ungroup() %>%
  filter(n > 1)

watersurfaces_ranking_not_unique <- mhq_watersurfaces_samplingunits %>%
  group_by(grts_ranking) %>%
  mutate(n = n()) %>%
  ungroup() %>%
  filter(n > 1)

```




### Check for sampling units without unique grts_ranking

Not all sampling units have a unique grts-ranking. See map below.

```{r}
watersurfaces_ranking_not_unique %>%
  st_transform(4326) %>%
  mutate(show_color = ifelse(set == "selection2014", "yellow", "red")) %>%
  leaflet() %>%
  addTiles() %>%
  addPolygons(label = ~grts_ranking, color = ~show_color)
```



## Visualise data

The map below shows: 

+ original sampling units selected in 2014 (yellow polygons)

+ potential extra sampling units selected in 2016 (red polygons)

+ reference points (markers)

```{r}

mhq_watersurfaces_samplingunits %>%
  st_transform(crs = 4326) %>%
  mutate(show_color = ifelse(set == "selection2014", "yellow", "red")) %>%
  leaflet() %>%
  addTiles() %>%
  addPolygons(label = ~type_target_all, color = ~show_color) %>%
  addMarkers(data = st_transform(mhq_watersurfaces_refpoints, 4326), popup = ~pol_id)
```

Some sampling units selected in 2014 overlap with those of the 2016 sample frame. 


```{r}

sample_2014_overlap <- sample_2014_sf %>%
  st_join(select(sampleframe_31xx_2016_sf, pol_id_overlap = pol_id), largest = TRUE) %>%
  filter(!is.na(pol_id_overlap))

sampleframe_2016_overlap <- sampleframe_31xx_2016_sf %>%
  st_join(select(sample_2014_overlap, pol_id_overlap = pol_id), largest = TRUE) %>%
  filter(!is.na(pol_id_overlap))

sample_2014_overlap %>%
  st_transform(4326) %>%
  leaflet() %>%
  addTiles() %>%
  addPolygons(color = "yellow") %>%
  addPolygons(data = st_transform(sampleframe_2016_overlap, 4326), color = "red")
```




```{r, eval = FALSE}
mhq_watersurfaces_samplingunits %>%
  st_write(dsn = "../output/mhq_watersurfaces.gpkg", layer = "samplingunits_original")

mhq_watersurfaces_refpoints %>%
  st_write(dsn = "../output/mhq_watersurfaces.gpkg", layer = "samplingunits_refpoints")

```



<!--chapter:end:10_sample_original.Rmd-->

# Assessments of sampling units

## Admin data for watersurfaces

An overview of the assessed watersurfaces is provided 

+ in the file OverzichtMeetnet&Steekproef_HT31XX_11_12_2020.xlsx for types 31xx
+ in the file Steekproefkader_2190_versie20170606.shp

Both files can be found in [this google drive folder](https://drive.google.com/drive/folders/19NsppwrC47ZAjv8Ndoh6aChkdud801T2).


### Habitat types 31xx

The admin data provide information on:
+ type observed
+ area class observed
+ the year in which an abiotic measurement was performed
+ the yeat in which an biotic measurement was performed
+ the code of the actual watersurface that was assessed (the polygons of the 2014 sample can contain several watersurfaces)
+ the code that is used in inboveg

```{r}
admin_orig <- read_excel("../data/OverzichtMeetnet&Steekproef_HT31XX_11_12_2020.xlsx")

admin_assessments_watersurfaces <- admin_orig %>%
  mutate(sac = ifelse(!is.na(SBZH), SBZH, SBZ)) %>%
  select(pol_id = ID_Plas, sac, type_target = doelhabt, code_inboveg = CODE, code_watersurfaces =  Watervlakk, monitoring_type = meetnet, assessment = geprospecteerd, year_abiotic = Abiotiek_j, year_biotic = Biotiek_ja, is_type_target = Doelhabitat, type_observed = HabtypeVel, note = Opmerking2, area_class_observed = starts_with("Werkelijke") ) %>%
  mutate(type_observed = ifelse(type_observed == "?", "unknown", type_observed),
         assessment = ifelse(pol_id == "extra", "ja", assessment),
         pol_id = ifelse(pol_id == "extra", str_c("extra_", code_inboveg), pol_id),
         code_watersurfaces = ifelse(code_inboveg == "WV_LEI_001", "WVLOSK0532", code_watersurfaces), #correction after manual check: TO BE CORRECTED in admin data source
         area_class_observed = factor(area_class_observed, levels = c("Opp <= 1 ha", "1 ha < Opp <= 5 ha", "5 ha < Opp < 50 ha", "> 50 ha"))) %>%
  mutate(assessment = assessment == "ja" & !is.na(assessment)) %>%
  filter(assessment) %>%
  group_by(pol_id, sac, code_inboveg, code_watersurfaces, monitoring_type, assessment, year_abiotic, year_biotic, type_observed, area_class_observed, note) %>%
  summarise(n_target_types = n(),
         any_type_target = "ja" %in% is_type_target) %>%
  ungroup()

admin_assessments_watersurfaces_types <- admin_assessments_watersurfaces %>%
  separate_rows(type_observed, sep = ";")

```




### Habitattype 2190

```{r}

watersurfaces <- read_watersurfaces() %>%
  select(code_watersurfaces = polygon_id)

admin_2190_orig <- read_sf("../data/voortgang_2190/Steekproefkader_2190_versie20170606.shp") %>%
  st_drop_geometry() 

admin_assessments_2190 <- admin_2190_orig %>%
  mutate(sac = ifelse(!is.na(SBZH), SBZH, SBZ),
         assessment = !is.na(CODE),
         type_observed = ifelse(Abiotiek_j != 0, "2190", NA),
         any_type_target = ifelse(Abiotiek_j != 0, TRUE, NA),
         note = ifelse(str_sub(CODE, 1, 2) == "WV", str_sub(CODE, 11), CODE),
         code_inboveg = ifelse(str_sub(CODE, 1, 2) == "WV", str_sub(CODE, 1, 10), NA),
         area_class_observed = ifelse(OppKlasse == "1 ha < Opp <= 5 ha", OppKlasse, "Opp <= 1 ha")) %>%
  select(pol_id = ID_plas, sac, type_observed, code_inboveg, assessment, year_abiotic = Abiotiek_j, year_biotic = Biotiek_ja,  type_observed, note, area_class_observed, any_type_target) %>%
  mutate(area_class_observed = factor(area_class_observed, levels = c("Opp <= 1 ha", "1 ha < Opp <= 5 ha", "5 ha < Opp < 50 ha", "Opp >= 50 ha"))) %>%
  filter(assessment) %>%
  mutate(pol_id = as.character(pol_id),
         year_abiotic = ifelse(year_abiotic == 0, NA, year_abiotic),
         year_biotic = ifelse(year_biotic == 0, NA, year_biotic),
         n_target_types = 1,
         monitoring_type = "habitat")

admin_assessments_watersurfaces_types <- admin_assessments_watersurfaces_types %>%
  bind_rows(admin_assessments_2190)

check <- admin_assessments_watersurfaces_types %>%
  group_by(pol_id, type_observed) %>%
  mutate(n_recs = n()) %>%
  ungroup() %>%
  filter(n_recs > 1)

```


## Join sampling units data and admin data

```{r}
# one record per polygon
mhq_watersurfaces_pol <- mhq_watersurfaces_types %>%
  group_by(pol_id, sac, grts_ranking, grts_ranking_draw, set) %>%
  arrange(type_target, area_class) %>%
  summarise(type_target_all = str_c(type_target, collapse = ";"),
            area_class_all = str_c(area_class, collapse = ";")) %>%
  ungroup()

check <- unique(mhq_watersurfaces_pol$pol_id) == nrow(mhq_watersurfaces_pol)

assessments_mhq_watersurfaces <- mhq_watersurfaces_pol %>%
  full_join(admin_assessments_watersurfaces_types, by = c("pol_id", "sac")) %>%
  mutate(measurement_biotic = (!is.na(year_biotic)) & (year_biotic != 0),
         measurement_abiotic = (!is.na(year_abiotic)) & (year_abiotic != 0),
         is_type_target = str_detect(type_target_all, type_observed),
         is_type_target = ifelse(is.na(is_type_target) & assessment, FALSE, is_type_target),
         set = ifelse(is.na(set), "extra", set)) #%>%
  # filter(assessment & !is.na(assessment))

# check unique pol_id/type_observed
check <- assessments_mhq_watersurfaces %>%
  group_by(pol_id, type_observed) %>%
  mutate(n_recs = n()) %>%
  ungroup() %>%
  filter(n_recs > 1)


check_any_type_target <- assessments_mhq_watersurfaces %>%
  filter(!is.na(type_observed)) %>%
  mutate(is_type_target_check = str_detect(type_target_all, type_observed)) %>%
  group_by(pol_id, grts_ranking, type_target_all, any_type_target) %>%
  summarise(any_type_target_check = any(is_type_target_check),
            type_observed_all = str_c(type_observed, collapse = ";"),
            set = str_c(unique(set), collapse = ";")) %>%
  ungroup() %>%
  filter(any_type_target_check != any_type_target)
  
```

### Extra watersurfaces

The admin data contains some extra watersurfaces which are not included in the initially selected sampling units. 
These extra watersurfaces were measured for two reasons:

+ the watersurface contains a type for which it was decided to select and measure all exisiting sampling units
+ the watersurface replaces a nearby sampling unit which did not contain the target type 

We determine the grts-ranking of the extra watersurfaces using point_on_surface.

```{r}
mhq_watersurfaces_refpoints_extra <- assessments_mhq_watersurfaces %>%
  filter(set == "extra") %>%
  distinct(pol_id, code_watersurfaces) %>%
  left_join(watersurfaces, by = "code_watersurfaces") %>%
  st_as_sf() %>%
  st_point_on_surface() %>%
  mutate(grts_ranking_extra = grts_master[as(., "Spatial")]) 

assessments_mhq_watersurfaces <- assessments_mhq_watersurfaces %>%
  left_join(st_drop_geometry(mhq_watersurfaces_refpoints_extra), by = c("code_watersurfaces", "pol_id")) %>%
  mutate(grts_ranking = ifelse(is.na(grts_ranking) & set == "extra", grts_ranking_extra, grts_ranking)) %>%
  select(-grts_ranking_extra)
```

### Handle replacements

```{r}
coord_extra <- mhq_watersurfaces_refpoints_extra %>%
  st_drop_geometry() %>%
  mutate(x = st_coordinates(mhq_watersurfaces_refpoints_extra)[,1],
         y = st_coordinates(mhq_watersurfaces_refpoints_extra)[,2]) %>%
  select(-grts_ranking_extra, -code_watersurfaces) 

coord_sample_replaced <- mhq_watersurfaces_refpoints %>%
  st_drop_geometry() %>%
  mutate(x_replaced = st_coordinates(mhq_watersurfaces_refpoints)[,1],
         y_replaced = st_coordinates(mhq_watersurfaces_refpoints)[,2]) %>%
  select(-grts_ranking) %>%
  rename(pol_id_replaced = pol_id)

coord_sample <- mhq_watersurfaces_refpoints %>%
  st_drop_geometry() %>%
  mutate(x = st_coordinates(mhq_watersurfaces_refpoints)[,1],
         y= st_coordinates(mhq_watersurfaces_refpoints)[,2]) %>%
  select(-grts_ranking)

replacement_31xx <- assessments_mhq_watersurfaces %>%
  filter(str_detect(note, c("verschuiving van|verschoven van"))) %>%
  mutate(pol_id_replaced = word(note, -1)) %>%
  filter(set == "extra") %>%
  select(-grts_ranking_draw, -type_target_all, -area_class_all) %>%
  left_join(select(assessments_mhq_watersurfaces, pol_id_replaced = pol_id, grts_ranking_draw, type_target_all, area_class_all, code_watersurfaces_replaced = code_watersurfaces), by = "pol_id_replaced") %>%
  distinct() %>%
  mutate(replaced = TRUE,
         is_type_target = str_detect(type_target_all, type_observed)) %>%
  left_join(coord_extra, by = "pol_id") %>%
  left_join(coord_sample_replaced, by = "pol_id_replaced") %>%
  mutate(distance_replaced = round(sqrt((x - x_replaced) ^ 2 + (y - y_replaced) ^ 2 ), 0))


replaced_2190 <- assessments_mhq_watersurfaces %>%
  filter(str_detect(note, c("verschuiving naar|verschoven naar"))) %>%
  mutate(code_inboveg_replacement = word(note, -1),
         code_inboveg_replacement = ifelse(!str_detect(code_inboveg_replacement, "WV"), str_c("WV_", code_inboveg_replacement),
                                           code_inboveg_replacement)) %>%
  filter(type_target_all == "2190") %>%
  select(code_inboveg = code_inboveg_replacement, pol_id_replaced = pol_id, grts_ranking_draw)

replacement_2190 <- assessments_mhq_watersurfaces %>%
  filter(str_detect(note, c("verschuiving van|verschoven van"))) %>%
  mutate(code_inboveg_replaced = word(note, -1)) %>%
  filter(set != "extra") %>%
  select(-grts_ranking_draw) %>%
  left_join(replaced_2190, by = "code_inboveg") %>%
  distinct() %>%
  mutate(replaced = TRUE) %>%
  left_join(coord_sample, by = "pol_id") %>%
  left_join(coord_sample_replaced, by = "pol_id_replaced") %>%
  mutate(distance_replaced = round(sqrt((x - x_replaced) ^ 2 + (y - y_replaced) ^ 2 ), 0))



replacement <- bind_rows(replacement_2190,
                         replacement_31xx)

```

The table below provides an overview of the replaced sampling units.

+ The target type of the original sampling unit should be the same as the observed type in the newly selected sampling unit. This is not the case for one sampling unit.
+ The table also provides the distance between reference points. 
+ For one sampling unit it could not be identified which sampling unit it replaces (NOD_011: to be checked!)

```{r}
replacement %>%
  select(code_watersurfaces, pol_id, pol_id_replaced, type_target_all, type_observed, "distance_replaced (m)" =  distance_replaced, note) %>%
  kable() %>%
  kable_styling()
```

We also check the admin data for the original sampling units. 
The table below shows that for most records the target type was not observed (is_type_target = FALSE), as expected.  
Only one sampling unit contains the target type and was measured, yet another sampling unit was selected nearby as a replacement. 
To be checked with field workers!

```{r}
replaced <- assessments_mhq_watersurfaces %>%
  filter(str_detect(note, "verschuiving naar|verschoven naar")) %>%
  mutate(pol_id_replacement = word(note, -1))

replaced %>%
  select(pol_id, pol_id_replacement, type_target_all, type_observed, is_type_target, year_biotic, note) %>%
  kable() %>%
  kable_styling()

```

```{r}
assessments_mhq_watersurfaces <- assessments_mhq_watersurfaces %>%
  anti_join(replacement, by = "pol_id") %>%
  bind_rows(select(replacement, -x, -y, -x_replaced, -y_replaced, -code_watersurfaces_replaced))

mhq_watersurfaces_refpoints <- mhq_watersurfaces_refpoints %>%
  bind_rows(select(mhq_watersurfaces_refpoints_extra, pol_id, grts_ranking = grts_ranking_extra, geometry = geom))
```

### Sampling units that are not accessible

Some sampling units can not be assessed since they are on private property and no access is provided.
For these sampling units we set the variable inaccessible to 'long term'. The variable is_type_target is set to NA.

```{r}

assessments_mhq_watersurfaces <- assessments_mhq_watersurfaces %>%
  mutate(inaccessible = ifelse(str_detect(note, "priv"), "long term", NA),
         is_type_target = ifelse(!is.na(inaccessible), NA, is_type_target),
         any_type_target = ifelse(!is.na(inaccessible), NA, any_type_target),
         assessment = ifelse(!is.na(inaccessible), FALSE, assessment))

```


### Sampling units that were not considered for assessment

When sampling units does not contain the target type new sampling units have to be selected based on the grts-ranking. 
In some cases it was decided not the assess a new sampling unit that should have been selected according to the grts-ranking. 
This because the new sampling unit was located in a region in which already sufficient sampling units were measured.

```{r}
assessments_mhq_watersurfaces %>%
  filter(str_detect(note, "te veel")) %>%
  select(pol_id, type_target_all, note) %>%
  kable() %>%
  kable_styling()
```

These sampling units are not assessed and therefore removed from the assessment admin table.

```{r}
assessments_mhq_watersurfaces <- assessments_mhq_watersurfaces %>%
  # filter(!str_detect(note, "te veel") | is.na(note)) 
  mutate(assessment = ifelse(str_detect(note, "te veel") & !is.na(note), FALSE, assessment),
         is_type_target = ifelse(str_detect(note, "te veel"), NA, is_type_target),
         any_type_target = ifelse(str_detect(note, "te veel"), NA, any_type_target))
```


## Defining the spatial extent of the sampling unit more precisely

The initial sampling units were selected based on the habitatmap. 
The selected polygons did not always fully match with the actual watersurface and some polygons contain various watersurfaces.

Today we have the watersurface layer, which precisely locates all watersurfaces in Flanders.
We will use this layer to define the spatial extent of the sampling units. 
However we will keep the orignal reference points as these are used to assign the grts-ranking to each sapling unit.


```{r}

mhq_watersurfaces_samplingunits2 <- mhq_watersurfaces_samplingunits %>%
  st_join(watersurfaces) %>%
  left_join(select(assessments_mhq_watersurfaces, pol_id, code_watersurfaces_recorded = code_watersurfaces, assessment, inaccessible, measurement_biotic, measurement_abiotic), by = "pol_id") %>%
  group_by(pol_id) %>%
    mutate(n_overlap = n_distinct(code_watersurfaces)) %>%
  ungroup() 
```

### Check measured 31xx watersurfaces

For types 31xx the code (from the watersurfaces data source) of the measured watersurface is recorded. 

```{r}
# measured 

check_measured_31xx <- mhq_watersurfaces_samplingunits2 %>%
  st_drop_geometry() %>%
  unique() %>%
  filter(!is.na(assessment)) %>%
  filter(type_target_all != "2190") %>%
  filter(measurement_biotic | measurement_abiotic) %>%
  mutate(check_code = code_watersurfaces == code_watersurfaces_recorded) %>%
  group_by(pol_id) %>%
  mutate(n_match_code = sum(check_code),
         n_overlap = n_distinct(code_watersurfaces)) %>%
  ungroup()

check_1measurement_per_samplingunit <- all((check_measured_31xx %>%
  filter(n_overlap > 1))$n_match_code == 1)
```

Several of the original sampling units contain more than one watersurface (defined by the watersurface data source).
If this is the case, only one of the watersurfaces is measured.
The spatial extent of the original sampling unit is replaced by the spatial extent of the measured watersurface.
However we keep the original reference point, as this point defines the grts-ranking on which the sample is based.
When a sampling unit contains more than one watersurfaces, we consider the watersurfaces that were not measured as not assessed.
This is because we do not know if the target type is present in these different watersurfaces. 
These watersurfaces have to be added to the sampling frame

The table below gives the distribution of the number of overlaps between the original sampling units and the watersurfaces.

```{r}
check_measured_31xx %>%
  distinct(pol_id, n_overlap) %>%
  group_by(n_overlap) %>%
  summarise(n_pol = n_distinct(pol_id)) %>%
  ungroup() %>%
  select("number of sampling units" = n_pol, "number of overlap with watersurfaces" = n_overlap) %>%
  kable() %>%
  kable_styling()
```

In the table below we list the polygons for which the recorded code does not correspond with the code of the overlapping watersurface.
In two cases the recorded code does not exist, so a recording error occured.
In two other cases the recorded code corresponds to a nearby watersurface, so a replacement was performed that was not documented.
We correct the codes, and we handle the replacements as specified above.


```{r}
wrong_code <- check_measured_31xx %>%
  filter(n_match_code == 0) %>%
  select(pol_id, code_watersurfaces, code_watersurfaces_recorded)  %>%
  mutate(code_recorded_exists = code_watersurfaces_recorded %in% watersurfaces$code_watersurfaces)

wrong_code %>%
  kable() %>%
  kable_styling()

```



```{r}

extra_replacement_refpoints <- watersurfaces %>%
  filter(code_watersurfaces %in% wrong_code$code_watersurfaces_recorded) %>%
  st_point_on_surface() %>%
  mutate(grts_ranking_extra = grts_master[as(., "Spatial")],
         pol_id = str_c("extra_", code_watersurfaces))

coords_extra_replacement <- extra_replacement_refpoints %>%
  st_drop_geometry() %>%
  mutate(x = st_coordinates(extra_replacement_refpoints)[, 1],
         y = st_coordinates(extra_replacement_refpoints)[, 2]) %>%
  select(pol_id, x, y)
  
replacement <- assessments_mhq_watersurfaces %>%
  select(-pol_id_replaced, -grts_ranking) %>%
  rename(pol_id_replaced = pol_id) %>%
  inner_join(st_drop_geometry(extra_replacement_refpoints), by = c("code_watersurfaces")) %>%
  rename(grts_ranking = grts_ranking_extra) %>%
  left_join(coords_extra_replacement, by = "pol_id") %>%
  left_join(coord_sample_replaced, by = "pol_id_replaced") %>%
  mutate(distance_replaced = sqrt((x - x_replaced)^2 + (y - y_replaced)^2),
         replaced = TRUE) %>%
  select(-x, -x_replaced, -y, -y_replaced)

correction <- wrong_code %>%
  select(pol_id, code_watersurfaces, replaced = code_recorded_exists)

replaced <- assessments_mhq_watersurfaces %>%
  select(-replaced, -code_watersurfaces) %>%
  inner_join(correction, by = c("pol_id")) %>%
  mutate(type_observed = ifelse(replaced, NA, type_observed),
         area_class_observed = ifelse(replaced, NA, as.character(area_class_observed)),
         year_abiotic = ifelse(replaced, NA, year_abiotic),
         year_biotic = ifelse(replaced, NA, year_biotic),
         measurement_abiotic = ifelse(replaced, FALSE, measurement_abiotic),
         measurement_biotic = ifelse(replaced, FALSE, measurement_biotic),
         is_type_target = ifelse(replaced, FALSE, is_type_target),
         any_type_target = ifelse(replaced, FALSE, any_type_target),
         note = ifelse(replaced, NA, note))
  
  
assessments_mhq_watersurfaces <- assessments_mhq_watersurfaces %>%
  anti_join(wrong_code, by = "pol_id") %>%
  bind_rows(replacement) %>%
  bind_rows(replaced)

mhq_watersurfaces_refpoints <- mhq_watersurfaces_refpoints %>%
  bind_rows(select(extra_replacement_refpoints, pol_id, grts_ranking = grts_ranking_extra, geometry = geom))


```



### Assessed 31xx sampling units that did not contain the target type

For the sampling units that did not contain the target type, the watersurface code was not recorded. 
We derive the watersurface code by overlaying the original sampling units with the watersurfaces.
When a sampling unit contains several watersurfaces, we assume that all of these watersurfaces do not contain the target type.
In this case, we create a record for each watersurface and we derive a new refpoint and grts_ranking using point_on_surface.
We only select the watersurfaces that overlap for more than 50% with the original sampling unit.

```{r}
# not measured 

watersurfaces <- watersurfaces %>%
  mutate(area_ws = drop_units(st_area(geom)))

fraction_overlap <- mhq_watersurfaces_samplingunits %>%
  select(pol_id) %>%
  st_intersection(watersurfaces) %>%
  mutate(area_overlap = drop_units(st_area(geometry))) %>%
  st_drop_geometry() %>%
  group_by(pol_id, code_watersurfaces, area_ws) %>%
  summarise(area_overlap = sum(area_overlap)) %>%
  ungroup() %>%
  mutate(prop_overlap = area_overlap/area_ws)
  
check_visited_31xx <- mhq_watersurfaces_samplingunits2 %>%
  st_drop_geometry() %>%
  unique() %>%
  filter(!is.na(assessment)) %>%
  filter(!measurement_abiotic & !measurement_biotic) %>%
  filter(type_target_all != "2190") %>%
  group_by(pol_id) %>%
  mutate(n_overlap = n_distinct(code_watersurfaces)) %>%
  ungroup() %>%
  left_join(fraction_overlap, by = c("code_watersurfaces", "pol_id"))

watersurfaces_no_target_type <- check_visited_31xx %>%
  filter(n_overlap == 1 | (n_overlap > 1 & prop_overlap > 0.5)) %>%
  select(pol_id, code_watersurfaces) %>%
  filter(!is.na(code_watersurfaces))

watersurfaces_no_target_type_refpoints <- watersurfaces_no_target_type %>%
  left_join(watersurfaces, by = "code_watersurfaces") %>%
  st_as_sf() %>%
  st_point_on_surface() %>%
  mutate(grts_ranking = grts_master[as(., "Spatial")]) %>%
  select(pol_id, code_watersurfaces, grts_ranking, geometry = geom)
  
assessments_watersurfaces_no_target_type <- assessments_mhq_watersurfaces %>%
  semi_join(watersurfaces_no_target_type, by = "pol_id") %>%
  select(-code_watersurfaces, -grts_ranking) %>%
  left_join(watersurfaces_no_target_type, by = "pol_id") %>%
  left_join(st_drop_geometry(watersurfaces_no_target_type_refpoints), by = c("pol_id", "code_watersurfaces"))

assessments_mhq_watersurfaces <- assessments_mhq_watersurfaces %>%
  anti_join(assessments_watersurfaces_no_target_type, by = "pol_id") %>%
  bind_rows(assessments_watersurfaces_no_target_type)

mhq_watersurfaces_refpoints <- mhq_watersurfaces_refpoints %>%
  filter(! pol_id %in% watersurfaces_no_target_type_refpoints$pol_id) %>%
  bind_rows(watersurfaces_no_target_type_refpoints)
```

### Assessed 2190 sampling units

For 2190 the watersurface code was not recorded during measurement.
However the sampling units almost fully match with the watersurfaces.
One polygon (WV_DHE_020) overlaps with 5 watersurface polygons: for now we assume that watersurface WVLBRD0089 is the correct watersurface: TO BE CHECKED!


```{r}
check_assessed_2190 <- mhq_watersurfaces_samplingunits2 %>%
  st_drop_geometry() %>%
  unique() %>%
  filter(!is.na(assessment) | !is.na(inaccessible)) %>%
  filter(type_target_all == "2190") %>%
  #filter(measurement_biotic | measurement_abiotic) %>%
  mutate(check_code = code_watersurfaces == code_watersurfaces_recorded) %>%
  group_by(pol_id) %>%
  mutate(n_match_code = sum(check_code),
         n_overlap = n_distinct(code_watersurfaces)) %>%
  ungroup()

check_1measurement_per_samplingunit <- all((check_measured_31xx %>%
  filter(n_overlap > 1))$n_match_code == 1)

no_overlap <- check_assessed_2190 %>%
  filter(is.na(code_watersurfaces))

add_code_2190 <- check_assessed_2190 %>%
  filter(n_overlap == 1 | code_watersurfaces == "WVLBRD0089") %>%
  select(pol_id, add_code_watersurfaces = code_watersurfaces) 

assessments_mhq_watersurfaces <- assessments_mhq_watersurfaces %>%
  left_join(add_code_2190, by = "pol_id") %>%
  mutate(code_watersurfaces = ifelse(!is.na(add_code_watersurfaces), add_code_watersurfaces, code_watersurfaces)) %>%
  select(-add_code_watersurfaces)
```

### Not assessed

We add the watersurface code to the sampling units that were not assessed.
If the original sampling unit contains more than one watersurface, we create a record for each sampling unit and recalculate the grts-ranking. The original grts-ranking is stored in grts_ranking_draw.

```{r}
check_not_assessed <- mhq_watersurfaces_samplingunits2 %>%
  st_drop_geometry() %>%
  unique() %>%
  filter(is.na(assessment) | !assessment) %>%
  filter(!is.na(code_watersurfaces)) %>%
  filter(set != "selection2014") %>%
  #filter(measurement_biotic | measurement_abiotic) %>%
  group_by(pol_id) %>%
  mutate(n_overlap_pol_id = n_distinct(code_watersurfaces)) %>%
  ungroup() %>%
  left_join(fraction_overlap, by = c("code_watersurfaces", "pol_id")) 

watersurfaces_not_assessed <- check_not_assessed %>%
  filter(n_overlap_pol_id == 1 | (n_overlap_pol_id > 1 & prop_overlap > 0.2)) %>%
  select(pol_id, code_watersurfaces, n_overlap_pol_id) %>%
  filter(!is.na(code_watersurfaces))

watersurfaces_not_assessed_overlap_refpoints <- watersurfaces_not_assessed %>%
  filter(n_overlap_pol_id > 1) %>%
  left_join(watersurfaces, by = "code_watersurfaces") %>%
  st_as_sf() %>%
  st_point_on_surface() %>%
  mutate(grts_ranking_new = grts_master[as(., "Spatial")]) %>%
  select(pol_id, code_watersurfaces, grts_ranking_new, geometry = geom)
  
assessments_watersurfaces_not_assessed<- assessments_mhq_watersurfaces %>%
  semi_join(watersurfaces_not_assessed, by = "pol_id") %>%
  select(-code_watersurfaces) %>%
  left_join(watersurfaces_not_assessed, by = "pol_id") %>% #add code watersurfaces
  left_join(st_drop_geometry(watersurfaces_not_assessed_overlap_refpoints), by = c("pol_id", "code_watersurfaces")) %>%
  mutate(grts_ranking = ifelse(!is.na(grts_ranking_new), grts_ranking_new, grts_ranking)) %>%
  select(-grts_ranking_new, -n_overlap_pol_id)

assessments_mhq_watersurfaces <- assessments_mhq_watersurfaces %>%
  anti_join(check_not_assessed, by = "pol_id") %>%
  bind_rows(assessments_watersurfaces_not_assessed)

mhq_watersurfaces_refpoints <- mhq_watersurfaces_refpoints %>%
  filter(! pol_id %in% watersurfaces_not_assessed_overlap_refpoints$pol_id) %>%
  bind_rows(rename(watersurfaces_not_assessed_overlap_refpoints, grts_ranking = grts_ranking_new))

```



### Watersurfaces that contain two original sampling units

Some of the assessed watersurfaces contain two of the original sampling units. 
This can be the case when two watersurfaces were merged in the latest version of the watersurfaces data source (which we use as a reference for defining the sampling units).  
In this case the admin data contains two records for one watersurface, one for each of the original sampling units.
However, both records refer to the same assessment and can be aggregated to one record.
In this aggregation we set grts_ranking_draw to the the minimum value of grts_ranking_draw for both original sampling units.
After aggregation we recalculate the grts_ranking based on the watersurface polygon using st_point_on_surface. 

```{r}
check_double <- assessments_mhq_watersurfaces %>%
  filter(!is.na(code_watersurfaces)) %>%
  group_by(pol_id, code_watersurfaces, set, grts_ranking, grts_ranking_draw, type_target_all, assessment, year_biotic, year_abiotic, measurement_biotic, measurement_abiotic) %>%
    summarise(type_observed_all = str_c(type_observed, collapse = "; ")) %>%
  ungroup() %>%
  group_by(code_watersurfaces) %>%
    mutate(n = n()) %>%
  ungroup() %>%
  filter(n > 1)


assessments_mhq_watersurfaces_double <- assessments_mhq_watersurfaces %>%
  semi_join(check_double, by = "code_watersurfaces") %>%
  group_by(code_watersurfaces, type_target_all, assessment, year_abiotic, year_biotic, type_observed, area_class_observed, n_target_types, any_type_target, measurement_biotic, measurement_abiotic, is_type_target, code_inboveg_replaced, pol_id_replaced, distance_replaced, inaccessible) %>%
  summarise(pol_id = str_c(pol_id, collapse = ";"),
            grts_ranking_draw = min(grts_ranking_draw),
            set = str_c(na.omit(set), collapse= ";"),
            monitoring_type = str_c(unique(monitoring_type), collapse= ";"),
            note = str_c(na.omit(note), collapse = ";"),
            replaced = any(replaced)) %>%
  ungroup() 

mhq_refpoints_double <-  assessments_mhq_watersurfaces_double %>%
  distinct(pol_id, code_watersurfaces) %>%
  left_join(watersurfaces, by = "code_watersurfaces") %>%
  st_as_sf() %>%
  st_point_on_surface() %>%
  mutate(grts_ranking = grts_master[as(., "Spatial")]) %>%
  select(pol_id, code_watersurfaces, grts_ranking, geometry = geom)

assessments_mhq_watersurfaces_double <- assessments_mhq_watersurfaces_double %>%
  left_join(st_drop_geometry(mhq_refpoints_double), by = c("pol_id", "code_watersurfaces"))

assessments_mhq_watersurfaces <- assessments_mhq_watersurfaces %>%
  anti_join(assessments_mhq_watersurfaces_double, by = "code_watersurfaces") %>%
  bind_rows(assessments_mhq_watersurfaces_double)

mhq_watersurfaces_refpoints <- mhq_watersurfaces_refpoints %>%
  filter(! code_watersurfaces %in% mhq_refpoints_double$code_watersurfaces) %>%
  bind_rows(mhq_refpoints_double)

```




## Standardize result


### mhq_watersurfaces_objects and mhq_watersurface_refpoints

```{r}
mhq_watersurfaces_objects <- assessments_mhq_watersurfaces %>%
  filter(!is.na(code_watersurfaces)) %>%
  distinct(code_watersurfaces, grts_ranking) %>%
  left_join(watersurfaces, by = "code_watersurfaces") %>%
  st_as_sf() %>%
  select(-area_ws)

check <- mhq_watersurfaces_objects %>%
  st_drop_geometry() %>%
  group_by(code_watersurfaces) %>%
  mutate(n = n()) %>%
  ungroup() %>%
  filter(n > 1)

check_geom <- !any(st_is_empty(mhq_watersurfaces_objects$geom))


add_code_watersurfaces <- assessments_mhq_watersurfaces %>%
  filter(!is.na(code_watersurfaces)) %>%
  distinct(pol_id, code_watersurfaces, grts_ranking)

mhq_watersurfaces_refpoints_2 <- mhq_watersurfaces_refpoints %>%
  select(-code_watersurfaces) %>%
  inner_join(add_code_watersurfaces, by = c("grts_ranking", "pol_id")) %>%
  # group_by(grts_ranking, code_watersurfaces) %>%
  # summarise(pol_id = str_c(unique(pol_id), collapse = ";")) %>%
  # ungroup() %>%
  st_join(select(mhq_watersurfaces_objects, code_watersurfaces_check = code_watersurfaces)) %>%
  mutate(in_object = !is.na(code_watersurfaces_check) & code_watersurfaces_check == code_watersurfaces) %>%
  select(-code_watersurfaces_check) 
# 
# check <- mhq_watersurfaces_refpoints_assessed %>%
#   group_by(grts_ranking) %>%
#   mutate(n = n()) %>%
#   ungroup() %>%
#   filter(n > 1)
# 
# check_geom <- !any(st_is_empty(mhq_watersurfaces_refpoints_assessed$geometry))
# 
# check_ranking <- mhq_watersurfaces_refpoints_assessed %>%
#   mutate(grts_ranking_check = grts_master[as(., "Spatial")]) %>%
#   filter(grts_ranking_check != grts_ranking)

```






```{r}
mhq_watersurfaces_objects %>%
  st_transform(4326) %>%
  leaflet() %>%
  addTiles() %>%
  addPolygons(popup = ~str_c("code_ws: ", code_watersurfaces), group = "objects") %>%
  addCircleMarkers(data = st_transform(mhq_watersurfaces_refpoints_2, 4326), 
                   label = ~str_c("pol_id: ", pol_id, "code_ws: ", code_watersurfaces), group = "refpoints",
                   color = ~ifelse(in_object, "green", "red")) %>%
  addLayersControl(overlayGroups = c("objects", "refpoints"))
```

### 


<!--chapter:end:20_admin_standingwater.Rmd-->

