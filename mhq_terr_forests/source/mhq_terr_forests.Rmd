---
title: "MHQ forest habitats: selection of sampling units to complete the first monitoring cycle"
author: Toon Westra
output:
  html_document:
    toc: true
    toc_float:
      collapsed: false
      smooth_scroll: false
    number_sections: true
    code_folding: hide
    warning: FALSE
date: "2024-03-11"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(sf)
library(git2rdata)
library(RODBC)
library(leaflet)
library(n2khab)
library(kableExtra)
library(terra)
library(buffeRs)
library(crosstalk)
```

# Sample size forest habitat types

See [this report](https://publicaties.vlaanderen.be/view-file/52364).

```{r}
sample_size <- read_vc("samplesize_mhq_terr_v2021", "../data")

sample_size_forest <- sample_size %>%
  filter(typeclass == "FS") %>%
  select(type, typelevel, sac, n_finite_flanders, n_extra_subtype) %>%
  unique() %>%
  mutate(n_extra_subtype = ifelse(type %in% c("9130_fm", "9120_qb"), 0, n_extra_subtype)) %>%
  group_by(type, typelevel) %>%
  summarise(n_finite_flanders = sum(n_finite_flanders),
            n_extra_subtype = sum(n_extra_subtype)) %>%
  ungroup() %>%
  mutate(n_total = n_finite_flanders + n_extra_subtype) 
```


# Available sampling units from Flemish Forest inventory

We make use of following data sources (see [google drive](https://drive.google.com/drive/folders/1TjONf7WuoEYM6TzfHp9UW5KVw6ljMDgs)):

+ `vbi_strata_v2024-01-24.accdb`: observed habitat type (only available for the more recently measured plots)
+ `vbi_meetproces_v2022-11-15.accdb`: recorded coordinates
+ `vbi_analysedatabank_v2023-08-22.accdb`: contains information on the plots for which vegetation and dendrometric data is recorded

For each plot we select the most recent inventory period and the corresponding coordinates and observations.

```{r}

db_strata <- "../data/vbi_strata_v2024-01-24.accdb"
db_meetproces <- "../data/vbi_meetproces_v2022-11-15.accdb"
db_analyse <- "../data/vbi_analysedatabank_v2023-08-22.accdb"

connect_db <-   odbcConnectAccess2007(db_strata)
strata_orig <- sqlFetch(connect_db, "tblplotstratadynamic")
odbcClose(connect_db)

connect_db <-   odbcConnectAccess2007(db_meetproces)
coordinaten_orig <- sqlFetch(connect_db, "tblcoordinaten")
odbcClose(connect_db)

connect_db <-   odbcConnectAccess2007(db_analyse)
bestandskarakt_orig <- sqlFetch(connect_db, "tbl2BestandskaraktKwal")
cover_species_vbi <- sqlFetch(connect_db, "tbl11VegetatieSamenstelling")
measurements_vbi <- sqlFetch(connect_db, "tbl4Vegetatie")
odbcClose(connect_db)

strata <- strata_orig %>%
  select(plot_id = IDPlots, segment_id = IDSegments, periode = Periode, landuse = LandUse, stand_type = StandType, type_observed = Habitat) %>%
  filter(!is.na(stand_type)) %>%
  select(-stand_type)

coordinaten <- coordinaten_orig %>%
  select(plot_id = idplots, x, y, type_coord = type, periode, plotweight)

bestandskarakt <- bestandskarakt_orig %>%
  select(plot_id = IDPlots, periode = Periode, segment_id = IDSegments, stand_type = v2_StandType)

measurements_vbi <- measurements_vbi %>%
  select(plot_id = IDPlots, segment_id = IDSegments, periode = Periode, veg_record = VegRecord, dendro_record = DendroRecord, dendro_record_zero = DendroRecordZero)

cover_species_vbi <- cover_species_vbi %>%
  select(plot_id = IDPlots, periode = Periode, layer = Layer, name_nl = NameNl, name_sc = NameSc, cover_categ =  Cover_categ, date_veg = DateVeg)
```

Based on the coordinates we make an overlay with [habitatmap_terr_2023] ADDLINK

```{r}
habmap_terr <- read_habitatmap_terr(keep_aq_types = FALSE)

```

Let's check the version.

```{r}
check_version <- tibble(version_name = "habitatmap_terr_2023_v1",
                        md5_zenodo = "aed93b1293021a83d3dbe2db50b46585",
                        md5_file = md5sum(file.path(fileman_up("n2khab_data"), "20_processed/habitatmap_terr/habitatmap_terr.gpkg")))

check_version %>%
  kable() %>%
  kable_styling()

```


```{r}
bestandskarakt_actual <- bestandskarakt %>%
  group_by(plot_id) %>%
  slice_max(periode) %>%
  ungroup() %>%
  filter(segment_id == 1) %>%
  filter(periode > 1) %>%
  filter(!is.na(stand_type))

vbi_meetpunten_sf <- bestandskarakt_actual %>%
  left_join(strata, by = c("plot_id", "periode", "segment_id")) %>%
  left_join(coordinaten, by = c("plot_id", "periode")) %>%
  st_as_sf(coords = c("x", "y"), crs = 31370) %>%
  st_join(select(habmap_terr$habitatmap_terr_polygons, polygon_id))

vbi_meetpunten_hab <- vbi_meetpunten_sf %>%
  st_drop_geometry() %>%
  left_join(habmap_terr$habitatmap_terr_types, by = "polygon_id") %>%
  mutate(main_type = str_sub(type, 1, 4)) %>%
  left_join(measurements_vbi, by = c("plot_id", "segment_id", "periode")) %>%
  mutate(measured = veg_record & (is.na(dendro_record) | (dendro_record | dendro_record_zero)))

```
## Samplesize per type based on overlay between plot coordinates and habitatmap_terr 

```{r}

vbi_samplesize_main_type <- vbi_meetpunten_hab %>%
  filter(!is.na(polygon_id)) %>%
  filter(certain) %>%
  filter(str_sub(type, 1, 1) == "9") %>%
  group_by(main_type, certain) %>%
  summarise(n_records = n(),
            n_prob = sum(phab/100)) %>%
  ungroup()

vbi_samplesize_type <- vbi_meetpunten_hab %>%
  filter(!is.na(polygon_id)) %>%
  filter(certain) %>%
  filter(str_sub(type, 1, 1) == "9") %>%
  group_by(type, certain) %>%
  summarise(n_records = n(),
            n_prob = sum(phab/100)) %>%
  ungroup()
```
The table below shows the expected number of sampling units (`n_prob`) per type based onthe overlay between plot coordiantes and habitatmap_terr.
Some polygons of the habitatmap contain different types or are only partially coverd by habitat.
This is expressed by the variable (`phab`), for example 70% 9120.
The probability that a plot contains the target type, is equal to the `phab` value.
So a plot that is situated in a polygon with 70% 9120 is counted as 0.7 sampling units for 9120.

```{r}
vbi_samplesize_main_type %>%
  kable() %>%
  kable_styling()
```
```{r}
vbi_samplesize_type %>%
  kable() %>%
  kable_styling()
```

## Samplesize based on observed types

```{r}
vbi_meetpunten_hab_observed <- vbi_meetpunten_hab %>%
  filter(!is.na(type_observed)) %>%
  filter(measured) %>%
  mutate(type_observed_std = ifelse(type_observed == "9 : bossen", "9xxx",
                                ifelse(!str_sub(type_observed, 1, 4) %in% vbi_samplesize_main_type$main_type, "gh", type_observed)),
         type_observed_std = str_replace(type_observed_std, " ", "_")) %>% 
  mutate(main_type_observed = str_sub(type_observed_std, 1, 4),
         main_type = ifelse(is.na(main_type), "gh", main_type),
         type = if_else(is.na(type), "gh", as.character(type)),
         phab = ifelse(is.na(phab), 100, phab))

accuracy_main_type_observed <- vbi_meetpunten_hab_observed %>%
  group_by(main_type, main_type_observed) %>%
  summarise(n_prob = sum(phab/100)) %>%
  ungroup() %>%
  filter(main_type %in% vbi_samplesize_main_type$main_type | main_type == "gh")

```
When we compare the observed type (`main_type_observed`) in the forest inventory with the type according to the habitatmap (`main_type`), we see quite a lot of differences, even when only comparing the main_type.
See the table below.

```{r}
accuracy_main_type_observed %>%
  arrange(main_type, main_type_observed) %>%
  pivot_wider(names_from = "main_type_observed", values_from = "n_prob", values_fill = 0) %>%
  select(main_type, "9110", "9120", "9130", "9160", "9190", "91E0", "9xxx", gh) %>%
  kable() %>%
  kable_styling() %>%
  add_header_above(header = c(" " = 1, "main_type observed" = 8))
```

Below we show the sample size per type for both sources.

```{r}
overzicht_vbi_observed <- vbi_meetpunten_hab_observed %>%
  group_by(type_observed_std) %>%
  summarise(n_vbi_observed = n_distinct(plot_id)) %>%
  ungroup() %>%
  rename(type = type_observed_std)

overzicht_vbi_habmap <- vbi_meetpunten_hab_observed %>%
  mutate(type = ifelse(str_sub(type, 1,1) != "9", "gh", type)) %>%
  group_by(type) %>%
  summarise(n_vbi_habitatmap = sum(phab/100)) %>%
  ungroup() 

overzicht_vbi <- overzicht_vbi_observed %>%
  full_join(overzicht_vbi_habmap, by = "type") %>%
  mutate(n_vbi_observed = replace_na(n_vbi_observed, 0),
         n_vbi_habitatmap = replace_na(n_vbi_habitatmap, 0))

check <- sum(overzicht_vbi$n_vbi_observed)
check2 <- sum(overzicht_vbi$n_vbi_habitatmap)

overzicht_vbi %>%
  arrange(type) %>%
  kable() %>%
  kable_styling()
```

Let's clean up a bit.

Let's first remove the records for which both the habitatmap type and the observed type does not belong to the 91xx habitat group.
This also includes the recorded habitat type `9 : bossen`.


```{r}
vbi_meetpunten_hab_observed_filter1 <- vbi_meetpunten_hab_observed %>%
  filter(str_sub(main_type, 1, 2) == "91" | str_sub(main_type_observed, 1, 2) == "91")

remove_filter1 <- vbi_meetpunten_hab_observed %>%
  anti_join(vbi_meetpunten_hab_observed_filter1, by = c("plot_id", "type"))
```

Some examples of removed records:

```{r}
remove_filter1 %>%
  select(plot_id, type_observed, polygon_id, type, main_type, phab) 
```

Next, we remove the plots with observed_type = no habitat `gh` and the plot is situated in a polygon that only partially contain 91xx.

```{r}
vbi_meetpunten_hab_observed <- vbi_meetpunten_hab_observed_filter1 %>%
  mutate(cover_91xx = ifelse(str_sub(main_type, 1, 2) == "91", phab, 0)) %>%
  group_by(plot_id) %>%
  mutate(phab_91xx = sum(cover_91xx),
         any_match_type = any(type_observed_std == type),
         any_match_main_type = any(main_type_observed == main_type),
         n_types = n()) %>%
  ungroup()

vbi_meetpunten_hab_observed_filter2 <- vbi_meetpunten_hab_observed %>%
  filter(!(type_observed_std == "gh" & phab_91xx < 100))
```

The removed records:

```{r}

remove_filter2 <- vbi_meetpunten_hab_observed %>%
  anti_join(vbi_meetpunten_hab_observed_filter2, by = c("plot_id", "type"))

remove_filter2 %>%
  select(plot_id, type_observed, polygon_id, type, main_type, phab, phab_91xx) 
```

In case of habitatmap polygons with different types, and when one of these types correspond with the observed type we remove the habitatmap type that does not correspond with the observed type.

```{r}

vbi_meetpunten_hab_observed_filter3 <- vbi_meetpunten_hab_observed_filter2 %>%
  filter(!(n_types > 1 & any_match_type & type != type_observed_std)) 

```

The removed records:

```{r}

remove_filter3 <- vbi_meetpunten_hab_observed_filter2 %>%
  anti_join(vbi_meetpunten_hab_observed_filter3, by = c("plot_id", "type"))

remove_filter3 %>%
  select(plot_id, type_observed_std, polygon_id, type, main_type, phab, any_match_type, n_types) 
```

Next, also in case of habitatmap polygons with different **main** types, and when one of these **main** types correspond with the observed **main** type we remove the habitatmap **main** type that does not correspond with the observed **main** type.

```{r}
vbi_meetpunten_hab_observed_filter4 <- vbi_meetpunten_hab_observed_filter3 %>%
  group_by(plot_id) %>%
  mutate(n_types = n(),
         n_main_types = n_distinct(main_type)) %>%
  ungroup() %>%
  filter(!(n_main_types > 1 & any_match_main_type & main_type != main_type_observed)) %>%
  filter(!(cover_91xx == 0 & phab_91xx > 0))
  
```

```{r}

remove_filter4 <- vbi_meetpunten_hab_observed_filter3 %>%
  anti_join(vbi_meetpunten_hab_observed_filter4, by = c("plot_id", "type"))

remove_filter4 %>%
  select(plot_id, type_observed_std, polygon_id, type, main_type, phab, any_match_main_type) 
```

Finally, we also remove the plots with stand_type = `open ruimte binnen bos` and`naaldhout`.

```{r}

vbi_meetpunten_hab_observed_filter5 <- vbi_meetpunten_hab_observed_filter4 %>%
  filter(!stand_type %in% c("open ruimte binnen bos", "naaldhout"))
  
prop_type_match <- sum(vbi_meetpunten_hab_observed_filter5$any_match_type) / nrow(vbi_meetpunten_hab_observed_filter5)

prop_main_type_match <- sum(vbi_meetpunten_hab_observed_filter5$any_match_main_type) / nrow(vbi_meetpunten_hab_observed_filter5)

```


```{r}
# notes from LG
# 161026 : plotcentrum valt in een beek, om die reden aangeduid als open ruimte binnen bos cfr ons protocol (jammer genoeg geen foto voorhanden)
# 207065 : opmerking “wilgenstruweel - heischraal grasland - 9190”: mozaïeksituatie + aangeduid als niet toegankelijk voor de meting
# 321136 : zeer dicht nat wilgenstruweel

remove_filter5 <- vbi_meetpunten_hab_observed_filter4 %>%
  anti_join(vbi_meetpunten_hab_observed_filter5, by = c("plot_id", "type"))

remove_filter5 %>%
  select(plot_id, stand_type, type_observed_std, polygon_id, type, main_type, phab) 
```

After these steps we see that the observed type corresponds with the habitatmap type for `r round(100 * prop_type_match)` % of the records.
When we only consider the main type, we have a match of `r round(100 * prop_main_type_match)` %.

Now, for some records we can decide what is the most probable type in case of a mismatch between the observed type and the habitatmap type.

+ Rule 1: When the observed type = `9 : bossen` and the habitatmap polygon contains only one forest type, we assume that the habitatmap type is correct.

+ Rule 2: When the observed type = `91E0*` and the habitatmap polygon contains only one 91E0 type, we assume that the habitatmap type is correct.

```{r}
vbi_meetpunten_hab_observed_rule1 <- vbi_meetpunten_hab_observed_filter5 %>%
  mutate(type_decided = ifelse(type_observed_std == type, type, NA),
         type_decided = ifelse(type_observed_std == "9xxx" & n_types == 1, type, type_decided),
         type_decided = ifelse(type_observed_std == "91E0*" & n_types == 1 & main_type == "91E0", type, type_decided))

```

Now, let 's check the result. Below we show the number of plots per type where we have a match between the habitatmap type and the observed type.

```{r}
vbi_meetpunten_hab_match <- vbi_meetpunten_hab_observed_rule1 %>%
  filter(!is.na(type_decided)) %>%
  group_by(type_decided) %>%
  summarise(samplesize_match = n_distinct(plot_id)) %>%
  ungroup() %>%
  rename(type = type_decided)

observed_nomatch <- vbi_meetpunten_hab_observed_rule1 %>% 
  filter(is.na(type_decided)) %>%
  group_by(type_observed_std) %>%
  summarise(samplesize_nomatch_observed = n_distinct(plot_id)) %>%
  ungroup() %>%
  rename(type = type_observed_std) %>%
  filter(str_sub(type, 1, 2) == "91") %>%
  mutate(type = ifelse(type == "91E0*", "91E0", type))

habitatmap_nomatch <- vbi_meetpunten_hab_observed_rule1 %>% 
  filter(is.na(type_decided)) %>%
  group_by(type) %>%
  summarise(samplesize_nomatch_habitatmap = sum(phab/100)) %>%
  ungroup() %>%
  filter(str_sub(type, 1, 2) == "91")

vbi_notobserved <- vbi_meetpunten_hab %>%
  filter(is.na(type_observed)) %>% 
  group_by(type) %>%
  summarise(samplesize_habitatmap_not_observed = sum(phab/100)) %>%
  ungroup() %>%
  filter(str_sub(type, 1, 2) == "91")
  
```

```{r}
vbi_samplesize <- vbi_notobserved %>%
  left_join(vbi_meetpunten_hab_match, by = "type") %>%
  left_join(observed_nomatch, by = "type") %>%
  left_join(habitatmap_nomatch, by = "type") %>%
  mutate(samplesize_match = ifelse(is.na(samplesize_match), 0, samplesize_match),
         samplesize_nomatch_observed = ifelse(is.na(samplesize_nomatch_observed), 0, samplesize_nomatch_observed)) %>%
  mutate(samplesize_min = samplesize_habitatmap_not_observed + samplesize_match + pmin(samplesize_nomatch_habitatmap, samplesize_nomatch_observed),
         samplesize_max = samplesize_habitatmap_not_observed + samplesize_match + pmax(samplesize_nomatch_habitatmap, samplesize_nomatch_observed),)
```

In the table below we show:

+ samplesize_habitatmap_not_observed: expected number of sampling units per type based on the forest inventory plots for which the observed type was not yet recorded (type is determined by overlay with the habitatmap)
+ samplesize_match: number of sampling units pet type for which the observed type corresponds with the habitatmap type
+ samplesize_nomatch_observed: number of sampling units pet type based on the observed type, in case there is no match betweeb the observed type and the habitatmap type
+ samplesize_nomatch_habitat: number of sampling units pet type based on the habitatmap type, in case there is no match betweeb the observed type and the habitatmap type

The minimum/maximum samplesize is then equal to samplesize_habitatmap_not_observed + samplesize_match + the minimum/maximum of samplesize_nomatch_observed and samplesize_nomatch_habitat.


```{r}
vbi_samplesize %>%
  kable() %>%
  kable_styling()
```

The records with no match should be checked manually, for example using orthophoto's and species lists.
Following files can be used:

+ `check_vbi_habitatmap.csv` contains the forest inventory plots for which the observed habitat type does not correspond to the habitatmap type

+ `check_vbi_habitatmap_specieslist.csv` contains the species lists for the plots in the file above

+ `vbi_habitatmap_not_observed.csv` contains habitatmap type for the forest inventory plots for which the habitatmap type has not yet been determined. 


```{r}

if (!file.exists("../output/habitatmap_source.csv")) {
  
  habitatmap <- read_habitatmap()

  habitatmap_source <- habitatmap %>%
    st_drop_geometry() %>%
    semi_join(vbi_meetpunten_hab, by = "polygon_id") %>%
    select(polygon_id, source_habitatmap = source)
  
  rm(habitatmap)
  
  write_csv2(habitatmap_source, "../output/habitatmap_source.csv")
  
} else {
  
  habitatmap_source <- read_csv2("../output/habitatmap_source.csv")
  
}

vbi_meetpunten_hab_observed <- vbi_meetpunten_hab_observed_rule1 %>%
  left_join(habitatmap_source, by = "polygon_id") 

check_vbi_habitatmap <- vbi_meetpunten_hab_observed %>%
  filter(is.na(type_decided)) %>%
  group_by(plot_id, stand_type, type_observed_std, polygon_id, source_habitatmap, periode, measured, veg_record, dendro_record, dendro_record_zero) %>%
  summarise(type_habitatmap = str_c(str_c(phab, " % ", type), collapse = "; ")) %>%
  ungroup() %>%
  left_join(coordinaten, by = c("plot_id", "periode")) %>%
  select(x, y, plot_id, periode, stand_type, type_observed_vbi = type_observed_std, type_habitatmap, polygon_id, source_habitatmap, vbi_measured = measured)

check_vbi_habitatmap_specieslist <- check_vbi_habitatmap %>%
  select(plot_id, periode, type_observed_vbi, type_habitatmap) %>%
  left_join(cover_species_vbi, by = c("periode", "plot_id")) %>%
  arrange(plot_id, layer)

check_vbi_habitatmap %>%
  write_csv2("../output/check_vbi_habitatmap.csv")

check_vbi_habitatmap_specieslist %>%
  write_csv2( "../output/check_vbi_habitatmap_specieslist.csv")

vbi_habitatmap_not_observed <- vbi_meetpunten_hab %>%
  filter(is.na(type_observed)) %>%
  left_join(habitatmap_source, by = "polygon_id") %>%
  group_by(plot_id, polygon_id, source_habitatmap) %>%
  summarise(type_habitatmap = str_c(str_c(phab, " % ", type), collapse = "; ")) %>%
  ungroup() %>%
  filter(!is.na(polygon_id)) %>%
  mutate(bron_kartering = ifelse(str_detect(source_habitatmap, "o"), "orthofoto interpretatie",
                       ifelse(str_detect(source_habitatmap, "l"), "literatuur",
                              ifelse(str_detect(source_habitatmap, "ex"), "externe experten", "terreinbezoek"))),
         jaar_kartering = as.numeric(str_sub(source_habitatmap, 1, 2)),
         jaar_kartering = ifelse(jaar_kartering < 50, jaar_kartering + 2000, jaar_kartering + 1900))
         
  
vbi_habitatmap_not_observed %>%
  write_csv2( "../output/vbi_habitatmap_not_observed.csv")
```

# Additional sampling units in MHQ

Based on 'assessments' table in [this repo](https://github.com/inbo/n2khab-mhq-data/tree/master/processed/fieldmap_mhq).


```{r}

mhq_assessments <- read_vc(file = "assessments", root = "../data/mhq_fieldmap")
mhq_assessments_forest <- mhq_assessments %>%
  filter(is.na(sampling_unit_code))

mhq_measurements_forest <- mhq_assessments_forest %>%
  filter(lsvi_measurement) %>%
  filter(!is.na(type_observed)) %>%
  mutate(grts_ranking = as.numeric(plot_id))

mhq_measured <- mhq_assessments_forest %>%
  filter(lsvi_measurement) %>% 
  filter(!is.na(type_observed)) %>%
  mutate(type_observed = ifelse(type_observed == "9130", "9130_end", type_observed)) %>%
  group_by(type_observed) %>%
  summarise(n_measured_extra = n_distinct(plot_id)) %>%
  ungroup() %>%
  rename(type = type_observed)

mhq_measured %>%
  kable() %>%
  kable_styling()
```


# Number of remaining sampling units to be measured in cycle 1

In the table below we show the minimim and maximum number of remaining sampling units (`n_extra_todo_min` and `n_extra_todo_max`) to reach the total sample size (`n_total`), taking into account the number of sampling units from the forest inventory and mhq 

We do not draw extra sampling units in the subtype 9120_qb and 9130_fm, as this was not included in the initial monitoring design.

```{r}
sample_size_to_do <- sample_size_forest %>%
  left_join(vbi_samplesize, by = "type") %>%
  mutate(samplesize_min = ifelse(is.na(samplesize_min), 0, samplesize_min),
         samplesize_max = ifelse(is.na(samplesize_max), 0, samplesize_max)) %>%
  mutate(n_extra_min = pmax(0, n_total - samplesize_max),
         n_extra_max = pmax(0, n_total - samplesize_min)) %>%
  left_join(mhq_measured, by = "type") %>%
  mutate(n_measured_extra = ifelse(is.na(n_measured_extra), 0, n_measured_extra)) %>%
  mutate(n_extra_todo_min = pmax(0, n_extra_min - n_measured_extra),
         n_extra_todo_max = pmax(0, n_extra_max - n_measured_extra),)

sample_size_to_do_anb <- sample_size_to_do %>%
  filter(type != "91E0_sf")

sample_size_to_do_anb_min_total <- sum(sample_size_to_do_anb$n_extra_todo_min)
sample_size_to_do_anb_max_total <- sum(sample_size_to_do_anb$n_extra_todo_max)

sample_size_to_do_anb_min_year <- sample_size_to_do_anb_min_total/3
sample_size_to_do_anb_max_year <- sample_size_to_do_anb_max_total/3


sample_size_to_do_anb %>%
  select(type, n_total,  n_extra_min, n_extra_max, n_extra_measured = n_measured_extra, n_extra_todo_min, n_extra_todo_max) %>%
  kable(digits = 1) %>%
  kable_styling()

samplesize_main_type <- sample_size_to_do_anb %>%
  mutate(main_type = str_sub(type, 1, 4)) %>%
  group_by(main_type) %>%
  summarise(n_main_type_max = pmax(0, sum(n_finite_flanders - samplesize_min - n_measured_extra)),
            n_main_type_min = pmax(0, sum(n_finite_flanders - samplesize_max - n_measured_extra))) %>%
  ungroup() %>%
  select(main_type, n_main_type_max, n_main_type_min)

samplesize_subtype <- sample_size_to_do_anb %>%
  filter(typelevel == "subtype") %>%
  mutate(n_subtype_max = pmax(0, n_total - samplesize_min - n_measured_extra),
            n_subtype_min = pmax(0, n_total - samplesize_max - n_measured_extra)) %>%
  select(type, n_subtype_max, n_subtype_min)
```

The total number of extra sampling units is between `r round(sample_size_to_do_anb_min_total)` and `r round(sample_size_to_do_anb_max_total)`.
If we want to do this in the period 2024 - 2026, we have to measure `r round(sample_size_to_do_anb_min_year)` and `r round(sample_size_to_do_anb_max_year)` a year.


## Drawing the sample

### Sample frame

We make use of the datasource `habmap_terr` which can be downloaden ADD LINK.

```{r}
habmap_terr <- read_habitatmap_terr(keep_aq_types = FALSE)

```

Let's check the version.

```{r}
check_version <- tibble(version_name = "habitatmap_terr_2023_v1",
                        md5_zenodo = "aed93b1293021a83d3dbe2db50b46585",
                        md5_file = md5sum(file.path(fileman_up("n2khab_data"), "20_processed/habitatmap_terr/habitatmap_terr.gpkg")))

check_version %>%
  kable() %>%
  kable_styling()

```

### Draw sample

We assing a grts_ranking to all population units by overlay the habitatmap with the grts_master (containing the grts-ranking).
A population unit in a mixed habitatmap polygon has a selection probability = PHAB.
When a population unit in a mixed habitatmap polygon is selected, but does not contain the target type, it has to be replaced the population unit whithin the same polygon that does contain the target type, with the lowest grts-ranking.


```{r}

if (!(file.exists("../output/grts_habmap_points.tsv") & file.exists("../output/grts_habmap_points_top250.tsv"))) {
  
  raster_runif <- terra::rast(file.path(fileman_up("n2khab_data"), "20_processed/raster_runif/raster_runif.tif"))
  
  min_phab <- 10
  
  habmap_types <- habmap_terr$habitatmap_terr_types %>%
      group_by(polygon_id, code_orig) %>%
        mutate(n = n()) %>%
      ungroup() %>%
      group_by(polygon_id, type) %>%
       summarise(phab = sum(phab/n),
                code_orig = str_c(code_orig, collapse = "; ")) %>%
      ungroup() %>%
      filter(phab > min_phab)
  
  habmap_polygons <- habmap_terr$habitatmap_terr_polygons %>%
      filter(polygon_id %in% habmap_types$polygon_id) 
  
  types <- read_types() %>%
    select(type, typelevel, main_type)
  
  sac <- read_admin_areas(dsn = "sac") %>%
    select(sac_code)
  
  grts_master <- read_GRTSmh()
  
  grts_habmap_mask <- grts_master %>%
      crop(habmap_polygons) %>%
      mask(habmap_polygons) 
  
  grts_habmap_points <- grts_habmap_mask %>%
    as.points() %>%
    st_as_sf()  %>%
    st_join(habmap_polygons) %>%
    st_join(sac) %>%
    mutate(sac = !is.na(sac_code)) %>%
    dplyr::select(polygon_id, grts_ranking = GRTSmaster_habitats, sac)
  
grts_habmap_points2 <- grts_habmap_points %>%
  mutate(prob = (terra::extract(raster_runif, grts_habmap_points))$raster_runif)
  
  grts_habmap_points <- grts_habmap_points2 %>%
    st_drop_geometry() %>%
    mutate(x = st_coordinates(grts_habmap_points)[,1],
           y = st_coordinates(grts_habmap_points)[,2])
  
  grts_habmap_points <- grts_habmap_points %>%
    filter(!is.na(polygon_id)) %>%
    left_join(habmap_types, by = "polygon_id")
  
  grts_habmap_points_top250 <- grts_habmap_points %>%
    group_by(type) %>%
    slice_min(grts_ranking, n = 250) %>%
    ungroup()
  
  write_vc(grts_habmap_points_top250, file = "grts_habmap_points_top250", 
           root = "../output", 
           sorting = c("type" ,"grts_ranking"), strict = FALSE)
  
   write_vc(grts_habmap_points, file = "grts_habmap_points", 
           root = "../output", 
           sorting = c("type" ,"grts_ranking"), strict = FALSE)
  
} else {
  
  grts_habmap_points_top250 <- read_vc(file = "grts_habmap_points_top250", root = "../output")
  grts_habmap_points <- read_vc(file = "grts_habmap_points", root = "../output")
}

grts_hab91xx <- grts_habmap_points_top250 %>%
  filter(str_sub(type, 1, 2) == "91")

grts_hab91xx_all <- grts_habmap_points %>%
  filter(str_sub(type, 1, 2) == "91") %>%
  semi_join(grts_hab91xx, by = "polygon_id")
```


```{r}

path = fileman_up("n2khab-mhq-data")

mhq_assessments <- read_vc(root = file.path(path, "processed/fieldmap_mhq/"), "assessments")

mhq_assessments <- mhq_assessments %>%
  mutate(grts_ranking = as.numeric(plot_id),
         type_observed = ifelse(type_observed == "9130", "9130_end", type_observed))

inaccessible <- mhq_assessments %>%
  filter(inaccessible == "long term")
 
no_habitat <- mhq_assessments %>%
  filter(str_detect(type_observed, "geen habitat") | type_observed == "9 : bossen")

sampleframe_hab91xx <- grts_hab91xx %>%
  anti_join(no_habitat, by = "grts_ranking") %>% 
  filter(type != "91E0_sf") %>%
  anti_join(inaccessible, by = "grts_ranking") %>%
  left_join(mhq_assessments, by = "grts_ranking") %>%
  mutate(main_type = str_sub(type, 1, 4)) %>%
   group_by(grts_ranking) %>%
  mutate(n_types = n_distinct(type),
         n_main_types = n_distinct(main_type)) %>%
  ungroup() %>%
  mutate(mixed_observed = n_types > 1 & !is.na(type_observed)) 

sampleframe_hab91xx_mixed_observed <- sampleframe_hab91xx %>%
  filter(mixed_observed) %>%
  group_by(grts_ranking) %>%
  mutate(any_match_type = any(type == type_observed),
         code_orig = str_c(code_orig, collapse = "; ")) %>%
  ungroup() %>%
  filter(!(any_match_type & type != type_observed)) %>%
  group_by(grts_ranking) %>%
  slice_head(n = 1) %>%
  ungroup()

sampleframe_hab91xx <- sampleframe_hab91xx %>%
  filter(!mixed_observed) %>%
  bind_rows(sampleframe_hab91xx_mixed_observed) %>%
  mutate(source = ifelse(is.na(type_observed), "habitatmap_terr_2023_v1",
                         ifelse(type_observed == type, "habitatmap_terr_2023_v1/assessment_cycle1",
                                "assessment_cycle1")),
         phab = ifelse(!is.na(type_observed), 100, phab),
         type = ifelse(!is.na(type_observed), type_observed, as.character(type)),
         ) %>%
  select(polygon_id, grts_ranking, sac, phab, prob, code_orig, main_type, type, type_observed, lsvi_measurement, assessment_source, date_assessment, cover_species_record, source, x, y, remark) %>% 
  arrange(type, grts_ranking) %>%
  mutate(selection_step1 = prob < phab/100)

ranking_main_type <- sampleframe_hab91xx %>%
  filter(selection_step1) %>%
  filter(!lsvi_measurement | is.na(lsvi_measurement)) %>%
  distinct(grts_ranking, main_type) %>%
  group_by(main_type) %>%
  mutate(rank_rel_main_type = rank(grts_ranking)) %>%
  ungroup()
  
sample_hab91xx <- sampleframe_hab91xx %>%
  filter(selection_step1) %>%
  filter(!lsvi_measurement | is.na(lsvi_measurement)) %>%
  left_join(ranking_main_type, by = c("main_type", "grts_ranking")) %>%
  group_by(type) %>%
  mutate(rank_rel_subtype = rank(grts_ranking)) %>%
  ungroup() %>%
  left_join(samplesize_main_type, by = "main_type") %>%
  left_join(samplesize_subtype, by = "type") %>%
  mutate(select_main_type = rank_rel_main_type <= ceiling(n_main_type_max),
         select_subtype = ifelse(is.na(n_subtype_max), FALSE, rank_rel_subtype <= ceiling(n_subtype_max))) %>%
  filter(select_main_type | select_subtype) %>%
  group_by(main_type, grts_ranking) %>%
  mutate(n_subtypes = n_distinct(type)) %>%
  ungroup() %>%
  group_by(grts_ranking) %>%
  mutate(n_types = n_distinct(type)) %>%
  ungroup()

```

### Select replacement sampling units

When a sampling unit is visited and it does not contain the target type, it has to be replaced with another sampling unit within the same habitatmap polygon.

We select the potentially suitable replacement sampling units, by selecting all sampling units within a square buffer of 7 x 7 grid cells within the same habitatmap polygon. 

For small habitatmap polygons this results in a limited number of replacement sampling units.
Therefore we select all sampling units within a habitatmap polygon that contains less than 50 sampling units or in case when there are less than 10 sampling units within the square buffer.

Every replacement sampling unit receives a ranking number corresponding to the raltive ranking:

+ according to the grts-ranking within the polygon (one ranking per sampling unit)
+ according to the grts-ranking within the buffer (we get more than one ranking per sampling unit when buffers overlap)

For large habitatmap polygons, the sampling unit with the lowest ranking within the buffer that contains the target type is selected as replacement sampling unit.
For smaller habitatmap polygons (< 50 sampling units or a buffer with < 10 sampling units) we take the lowest rnaking within the polygon.

Be aware that buffers of the selected sampling units can overlap.
So avoid selecting a replacement sampling unit that has already been selected for replacing another sampling unit.


```{r}

polygons_habitatmap <- habmap_terr$habitatmap_terr_polygons %>%
  filter(polygon_id %in% sample_hab91xx$polygon_id)

su_sf <- sample_hab91xx %>%
  mutate(x = round(x, 1),
         y = round(y, 1)) %>%
  mutate(point_code = str_c(grts_ranking, "_1")) %>%
  distinct(polygon_id, point_code, x, y) %>%
  st_as_sf(coords = c("x", "y"), crs = 31370)
i = 1

for (i in 1:nrow(su_sf)) {
  
  pol_id <- (su_sf %>%
    slice(i))$polygon_id
  
  p_code <- (su_sf %>%
    slice(i))$point_code
  
  point <- su_sf %>%
    slice(i) %>%
    buffer_square(length = 200) %>%
    st_as_sf() %>%
    mutate(polygon_id_vervang = pol_id,
           point_code_vervang = p_code)
  
  if (i == 1) {
    
    buffers <- point
    
  } else {
    buffers <- bind_rows(buffers,
                         point)
  }
  
}

st_crs(buffers) <- 31370

polygonen_point_code <- su_sf %>%
  st_drop_geometry() %>%
  group_by(polygon_id) %>%
  summarise(point_code_inpolygon = str_c(point_code, collapse = ";")) %>%
  ungroup()

vervangpunten <- grts_hab91xx_all %>%
  distinct(grts_ranking, x, y, polygon_id) %>%
  semi_join(su_sf, by = "polygon_id") %>%
  anti_join(sample_hab91xx, by = "grts_ranking") %>% # the already selected sampling units
  anti_join(no_habitat, by = "grts_ranking") %>% 
  anti_join(mhq_measurements_forest, by = "grts_ranking") %>% # the already measured sampling units
  anti_join(inaccessible, by = "grts_ranking") %>%
  group_by(polygon_id) %>%
  mutate(n_polygon = n_distinct(grts_ranking)) %>%
  ungroup() %>%
  st_as_sf(coords = c("x", "y"), crs = 31370) %>%
  st_join(buffers) %>%
  filter((polygon_id == polygon_id_vervang) | is.na(polygon_id_vervang)) %>% 
  group_by(polygon_id) %>%
  mutate(n_buffer = sum(!is.na(polygon_id_vervang))) %>%
  ungroup() %>%
  filter((!is.na(polygon_id_vervang)) | (n_buffer <= 10 & n_polygon < 50) ) %>%
  group_by(polygon_id) %>%
  mutate(rank_rel_polygon = rank(grts_ranking, ties.method = "min")) %>%
  ungroup() %>%
  group_by(polygon_id, point_code_vervang) %>%
  mutate(rank_rel_buffer = ifelse(!is.na(point_code_vervang), rank(grts_ranking), NA)) %>%
  ungroup() %>%
  select(polygon_id, point_code_vervang, grts_ranking, rank_rel_polygon, rank_rel_buffer, n_buffer, n_polygon) %>%
  left_join(polygonen_point_code, by = "polygon_id") %>%
  mutate(point_code_vervang = ifelse(is.na(point_code_vervang), point_code_inpolygon, point_code_vervang)) %>%
  separate_rows(point_code_vervang, sep = ";") %>%
  select(-point_code_inpolygon) %>%
  arrange(polygon_id, point_code_vervang, grts_ranking)

```

Below an example of a small polygon: 

+ first check if there is a suitable replacment sampling unit within the buffer (yellow points) around the selected sampling unit (red point)
+ if not select a sampling unit outside teh buffer (blue points)

```{r}

p_id <- "391330_v2023"

polygon <- polygons_habitatmap %>%
  filter(polygon_id == p_id)%>%
  st_transform(crs = 4326)

sampling_unit <- su_sf %>%
  filter(polygon_id == p_id) %>%
  st_transform(4326) 

vervangpunten %>%
  filter(polygon_id == p_id) %>%
  st_transform(4326) %>%
  mutate(show_color = ifelse(is.na(rank_rel_buffer), "blue", "yellow")) %>%
  leaflet() %>%
  addTiles() %>%
  addCircleMarkers(data = sampling_unit, color = "red") %>%
  addPolygons(data = polygon ) %>%
  addCircleMarkers(color = ~show_color, label = ~str_c("buffer: ", ifelse(is.na(rank_rel_buffer), "niet in buffer", rank_rel_buffer), "; polygon: ", rank_rel_polygon), labelOptions = labelOptions(noHide = TRUE, textOnly = TRUE))
```



Here a big one...

```{r}

multiple_points_per_polygon <- vervangpunten %>%
  st_drop_geometry() %>%
  distinct(point_code_vervang, polygon_id) %>%
  group_by(polygon_id) %>%
  filter(n() > 1) %>%
  ungroup()
  

p_id <- (multiple_points_per_polygon %>%
  slice_head(n = 1))$polygon_id


sd <- vervangpunten %>%
  filter(polygon_id == p_id) %>%
  st_transform(4326) 

sd <- SharedData$new(sd)

polygon <- polygons_habitatmap %>%
  filter(polygon_id == p_id)%>%
  st_transform(crs = 4326)

sampling_unit <- su_sf %>%
  filter(polygon_id == p_id) %>%
  st_transform(4326) 

bscols(
  list(
    bscols(
      widths = c(4, 4),
      "",
      filter_select("point_code_vervang", "Code meetpunt", sd, ~point_code_vervang)
      ),
    sd %>%
      leaflet() %>%
      addTiles() %>%
      addPolygons(data = polygon ) %>%
      addCircleMarkers(data = sampling_unit, color = "red", label = ~point_code) %>%
      addCircleMarkers(color = "yellow", label = ~rank_rel_buffer, labelOptions = labelOptions(noHide = TRUE, textOnly = TRUE))
  )
)
  
  
```

## Write results

+ list of selected sampling units: `mhq_forests_cycle1.csv`

```{r}
polygon_descr <- habmap_terr$habitatmap_terr_polygons %>%
  st_drop_geometry() %>%
  select(polygon_id, descritipton_habitatmap = description)

sample_hab91xx_output <- sample_hab91xx %>%
  mutate(type_meetpunt = ifelse(str_detect(source, "assessment"), "meetpunt al bezocht: habitattype al bepaald", "nieuw meetpunt"),
         uitvoer_opname = ifelse(select_main_type, "hoofdtype aanwezig", "subtype aanwezig"),
         x = round(x, 2),
         y = round(y, 2),
         point_code = str_c(grts_ranking, "_1")) %>%
  group_by(point_code, polygon_id, grts_ranking, main_type, type_meetpunt, uitvoer_opname, date_assessment, x, y) %>%
  summarise(habitattype = str_c(type, collapse = "+")) %>%
  ungroup() %>% 
  left_join(polygon_descr, by = "polygon_id") %>%
  select(point_code, polygon_id, descritipton_habitatmap, grts_ranking, hoofdtype = main_type, habitattype, everything()) %>%
  arrange(habitattype, grts_ranking)

write_csv2(sample_hab91xx_output, "../output/mhq_forests_cycle1.csv", na = "")

sample_hab91xx_output %>%
  slice_head(n = 5) 


```

+ replacement sampling units: `mhq_forests_vervangpunten.csv`

```{r}
vervangpunten_out <- vervangpunten %>%
  st_drop_geometry() %>%
  mutate(x = st_coordinates(vervangpunten)[,1],
         y = st_coordinates(vervangpunten)[,2]) %>%
  mutate(x = round(x, 2),
         y = round(y, 2)) %>%
  select(-n_buffer, -n_polygon)

write_csv2(vervangpunten_out, "../output/mhq_forests_vervangpunten.csv", na = "")

vervangpunten_out %>%
  slice_head(n = 5)
```
